{"version":3,"file":"MetaFilters.mjs","sourceRoot":"","sources":["../../tsSourcesProject/filters/MetaFilters.mts"],"names":[],"mappings":"AAAA,OAAO,EAKL,qBAAqB,EACtB,MAAM,wBAAwB,CAAA;AAiB/B,MAAM,UAAU,YAAY,CAAiC,CAAmB,EAAE,CAAmB,EAAE,GAAG,MAA0B;IAClI,OAAO,qBAAqB,CAAC,WAAW,EAAE,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAA;AACvE,CAAC;AAcD,MAAM,UAAU,KAAK,CAAiC,CAAmB,EAAE,CAAmB,EAAE,GAAG,MAA0B;IAC3H,OAAO,qBAAqB,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAA;AAChE,CAAC;AAeD,MAAM,UAAU,UAAU,CAAiC,EAAoB,EAAE,WAA6B;IAC5G,OAAO,qBAAqB,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC,EAAE,EAAE,WAAW,CAAC,CAAA;AACxE,CAAC","sourcesContent":["import {\n  FilterOptions,\n  SortableFilterOptions,\n  BaseSortableFilterOptions,\n  BaseFilterOptions,\n  InternalFilterOptions\n} from \"../cardinal-sdk-ts.mjs\"\nimport {Identifiable} from \"../model/base/Identifiable.mjs\";\n\n/**\n * Create filter options that match entities that satisfy all provided filters (at least 2 filters are required).\n *\n * If the first provided filter options {@link a} is sortable then these filter options are sortable using the same criteria as {@link a}.\n * If all filters options provided are base filters options then the returned filter options are also base options.\n *\n * @param a\n * @param b\n * @param others\n */\nexport function intersection<T extends Identifiable<string>>(a: BaseSortableFilterOptions<T>, b: BaseFilterOptions<T>, ...others: BaseFilterOptions<T>[]): BaseSortableFilterOptions<T>\nexport function intersection<T extends Identifiable<string>>(a: BaseFilterOptions<T>, b: BaseFilterOptions<T>, ...others: BaseFilterOptions<T>[]): BaseFilterOptions<T>\nexport function intersection<T extends Identifiable<string>>(a: SortableFilterOptions<T>, b: FilterOptions<T>, ...others: FilterOptions<T>[]): SortableFilterOptions<T>\nexport function intersection<T extends Identifiable<string>>(a: FilterOptions<T>, b: FilterOptions<T>, ...others: FilterOptions<T>[]): FilterOptions<T>\nexport function intersection<T extends Identifiable<string>>(a: FilterOptions<T>, b: FilterOptions<T>, ...others: FilterOptions<T>[]): FilterOptions<T> {\n  return InternalFilterOptions.getInstance().intersection(a, b, others)\n}\n\n/**\n * Create filter options that match entities that satisfy at least one of the provided filters (at least 2 filters are required).\n *\n * These options are never sortable.\n * If all filters options provided are base filters options then the returned filter options are also base options.\n *\n * @param a\n * @param b\n * @param others\n */\nexport function union<T extends Identifiable<string>>(a: BaseFilterOptions<T>, b: BaseFilterOptions<T>, ...others: BaseFilterOptions<T>[]): BaseFilterOptions<T>\nexport function union<T extends Identifiable<string>>(a: FilterOptions<T>, b: FilterOptions<T>, ...others: FilterOptions<T>[]): FilterOptions<T>\nexport function union<T extends Identifiable<string>>(a: FilterOptions<T>, b: FilterOptions<T>, ...others: FilterOptions<T>[]): FilterOptions<T> {\n  return InternalFilterOptions.getInstance().union(a, b, others)\n}\n\n/**\n * Create filter options that match entities that satisfy the {@link of} filter but do not satisfy the {@link subtracting} filter.\n *\n * If the first provided filter options {@link of} is sortable then these filter options are sortable using the same criteria as {@link of}.\n * If all filters options provided are base filters options then the returned filter options are also base options.\n *\n * @param of\n * @param subtracting\n */\nexport function difference<T extends Identifiable<string>>(of: BaseSortableFilterOptions<T>, subtracting: BaseFilterOptions<T>): BaseSortableFilterOptions<T>\nexport function difference<T extends Identifiable<string>>(of: BaseFilterOptions<T>, subtracting: BaseFilterOptions<T>): BaseFilterOptions<T>\nexport function difference<T extends Identifiable<string>>(of: SortableFilterOptions<T>, subtracting: FilterOptions<T>): SortableFilterOptions<T>\nexport function difference<T extends Identifiable<string>>(of: FilterOptions<T>, subtracting: FilterOptions<T>): FilterOptions<T>\nexport function difference<T extends Identifiable<string>>(of: FilterOptions<T>, subtracting: FilterOptions<T>): FilterOptions<T> {\n  return InternalFilterOptions.getInstance().difference(of, subtracting)\n}"]}