{"version":3,"file":"CryptoStrategies.mjs","sourceRoot":"","sources":["../../tsSourcesProject/crypto/CryptoStrategies.mts"],"names":[],"mappings":"AAUA,OAAO,EAAC,aAAa,EAAC,MAAM,4BAA4B,CAAC;AAEzD;;;;;;;;GAQG;AACH,MAAM,OAAO,gBAAgB;IAC3B;;;;;;;;;;;;;;;;;;OAkBG;IACH,iCAAiC,CAC/B,QAAwD,EACxD,gBAAgC,EAChC,gBAAkC;QAElC,MAAM,GAAG,GAAiE,EAAE,CAAA;QAC5E,KAAK,MAAM,IAAI,IAAI,QAAQ,EAAE,CAAC;YAC5B,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,EAAE,aAAa,EAAE,EAAE,EAAE,eAAe,EAAE,EAAE,EAAE,CAAA;QACtF,CAAC;QACD,OAAO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;IAC7B,CAAC;IAED;;;;;;;;OAQG;IACH,0BAA0B,CACxB,IAAuB,EACvB,gBAAgC;QAEhC,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;IAC9B,CAAC;IAED;;;;;;;;;;;;;OAaG;IACH,wBAAwB,CACtB,QAAiC,EACjC,UAAgC,EAChC,gBAAgC;QAEhC,OAAO,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;IACpC,CAAC;IAED;;;;;;OAMG;IACH,oCAAoC,CAChC,SAAkC;QAEpC,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,IAAI,aAAa,CAAC,GAAG,CAAC,CAAA;IAC7D,CAAC;IAED;;;;;;OAMG;IACH,mBAAmB,CACf,IAAkB,EAClB,GAAgB,EAChB,gBAAgC;QAElC,OAAO,OAAO,CAAC,OAAO,EAAE,CAAA;IAC1B,CAAC;CACF","sourcesContent":["import {SpkiHexString} from \"../model/specializations/SpkiHexString.mjs\";\nimport {DataOwnerWithType} from \"../model/DataOwnerWithType.mjs\";\nimport {KeypairFingerprintV1String} from \"../model/specializations/KeypairFingerprintV1String.mjs\";\nimport {CryptoActorStubWithType} from \"../model/CryptoActorStubWithType.mjs\";\nimport {KeyStorageFacade, StorageFacade} from \"../storage/StorageFacade.mjs\";\nimport {RecoveryResult} from \"./entities/RecoveryResult.mjs\";\nimport {RecoveryDataKey} from \"./entities/RecoveryDataKey.mjs\";\nimport {RecoveryApi} from \"../api/RecoveryApi.mjs\";\nimport {RsaAlgorithm, XCryptoService, XRsaKeypair} from \"./CryptoService.mjs\";\nimport {CardinalApis} from \"../sdk/CardinalSdk.mjs\";\nimport {DataOwnerType} from \"../model/DataOwnerType.mjs\";\n\n/**\n * Allows customizing the behavior of the crypto api to better suit your needs.\n *\n * An important task which should be done in these crypto strategies is public key verification: in general there is no guarantee that the public keys\n * stored in the iCure database are authentic, i.e. created by the data owner they are associated to. This is because the database admins or a\n * malicious attacker may have added his own public keys to the data owner's public keys.\n * Sharing any kind of data using unverified public keys could potentially cause a data leak: this is why when creating new exchange keys or when\n * creating recovery data only verified keys will be considered. For decrypting existing data instead unverified keys will be used without issues.\n */\nexport class CryptoStrategies {\n  /**\n   * Method called during initialization of the crypto API to validate keys recovered through iCure's recovery methods and/or to allow recovery of\n   * missing keys using means external to iCure.\n   * On startup the iCure sdk will try to load all keys for the current data owner and its parent hierarchy: if the sdk can't find some of the keys\n   * for any of the data owners (according to the public keys for the data owner in the iCure server) and/or the sdk could recover some private keys\n   * but can't verify the authenticity of the key pairs this method will be called.\n   * The recovered and verified keys will automatically be cached using the current api {@link KeyStorageFacade} and {@link StorageFacade}\n   *\n   * The input is a list containing an object for each data owner part of the current data owner hierarchy. The objects are ordered from the data\n   * for the topmost parent of the current data owner hierarchy (first element) to the data for the current data owner (last element).\n   *\n   * The returned value must be an object associating to each data owner id an object with:\n   * - `recoveredKeys`:\n   * - `keyAuthenticity`: an object\n   * @param keysData all information on unknown and unavailable keys for each data owner part of the current data owner hierarchy.\n   * @param cryptoPrimitives cryptographic primitives you can use to support the process.\n   * @param keyPairRecoverer a key pair recoverer you can use to support the process\n   * @return a map that associates to each given data owner id the recovered data.\n   */\n  recoverAndVerifySelfHierarchyKeys(\n    keysData: Array<CryptoStrategies.KeyDataRecoveryRequest>,\n    cryptoPrimitives: XCryptoService,\n    keyPairRecoverer: KeyPairRecoverer\n  ): Promise<{ [dataOwnerId: string]: CryptoStrategies.RecoveredKeyData }> {\n    const res: { [dataOwnerId: string]: CryptoStrategies.RecoveredKeyData } = {}\n    for (const data of keysData) {\n      res[data.dataOwnerDetails.dataOwner.id] = { recoveredKeys: {}, keyAuthenticity: {} }\n    }\n    return Promise.resolve(res)\n  }\n\n  /**\n   * The correct initialisation of the crypto API requires that at least 1 verified (or device) key pair is available for each data owner part of the\n   * current data owner hierarchy. If no verified key is available for any of the data owner parents the api initialisation will automatically fail,\n   * however if there is no verified key for the current data owner you can instead create a new crypto key.\n   * @param self the current data owner.\n   * @param cryptoPrimitives cryptographic primitives you can use to support the process.\n   * @return an instance of [KeyGenerationRequestResult] specifying how the SDK should behave.\n   * @throws Exception you can throw any exception, and it will simply propagate to the api initialisation method.\n   */\n  generateNewKeyForDataOwner(\n    self: DataOwnerWithType,\n    cryptoPrimitives: XCryptoService\n  ): Promise<boolean | XRsaKeypair> {\n    return Promise.resolve(true)\n  }\n\n  /**\n   * Verifies if the public keys of a data owner which will be the delegate of a new exchange key do actually belong to the person the data owner\n   * represents. This method is not called when the delegate would be the current data owner for the api.\n   *\n   * The user will have to obtain the verified public keys of the delegate from outside iCure, for example by email with another hcp, by checking the\n   * personal website of the other user, or by scanning verification qr codes at the doctor office...\n   *\n   * As long as one of the public keys is verified the creation of a new exchange key will succeed. If no public key is verified the operation will\n   * fail.\n   * @param delegate the potential data owner delegate.\n   * @param publicKeys public keys requiring verification, in spki hex-encoded format.\n   * @param cryptoPrimitives cryptographic primitives you can use to support the process.\n   * @return all verified public keys, in spki hex-encoded format.\n   */\n  verifyDelegatePublicKeys(\n    delegate: CryptoActorStubWithType,\n    publicKeys: Array<SpkiHexString>,\n    cryptoPrimitives: XCryptoService\n  ): Promise<Array<SpkiHexString>> {\n    return Promise.resolve(publicKeys)\n  }\n\n  /**\n   * Specifies if a data owner requires anonymous delegations, i.e. his id should not appear unencrypted in new secure\n   * delegations.\n   * This should always be the case for patient data owners.\n   * @param dataOwner a data owner.\n   * @return true if the delegations for the provided data owner should be anonymous.\n   */\n  dataOwnerRequiresAnonymousDelegation(\n      dataOwner: CryptoActorStubWithType\n  ): Promise<boolean> {\n    return Promise.resolve(dataOwner.type != DataOwnerType.Hcp)\n  }\n\n  /**\n   * Notifies that a new key for the current data owner was created.\n   * This method is called after the initialization of the other SDK apis.\n   * @param apis the initialized cardinal apis.\n   * @param key the newly created key.\n   * @param cryptoPrimitives cryptographic primitives you can use to support the process.\n   */\n  notifyNewKeyCreated(\n      apis: CardinalApis,\n      key: XRsaKeypair,\n      cryptoPrimitives: XCryptoService,\n  ): Promise<void> {\n    return Promise.resolve()\n  }\n}\n\n\nexport namespace CryptoStrategies {\n  /**\n   * A request to recover key data that was not found for a user.\n   */\n  export interface KeyDataRecoveryRequest {\n    /**\n     * The data owner for which the key data should be recovered.\n     */\n    readonly dataOwnerDetails: DataOwnerWithType\n    /**\n     * All public keys (in hex-encoded spki format) of `dataOwner` for which the authenticity status (verified or unverified) is\n     * unknown (no result was cached from a previous api instantiation and the key was not generated on the current device).\n     * This could include keys that were recovered automatically by the sdk and may have overlap with `unavailableKeys`.\n     */\n    readonly unknownKeys: Array<SpkiHexString>\n    /**\n     * All public keys (in hex-encoded spki format) of `dataOwner` for which the sdk could not recover a private key. May overlap\n     * (partially or completely) with `unknownKeys`.\n     */\n    readonly unavailableKeys: Array<UnavailableKeyInfo>\n  }\n\n  /**\n   * Data recovered for a data owner.\n   */\n  export interface RecoveredKeyData {\n    /**\n     * All keys recovered for the data owner, by public key.\n     * The sdk will automatically consider all recovered keys as verified.\n     * The public key should be in hex-encoded spki format or a fingerprint (last 32 characters of the hex-encoded spki\n     * representation)\n     */\n    readonly recoveredKeys: { [fp: KeypairFingerprintV1String | SpkiHexString]: XRsaKeypair }\n    /**\n     * Marks if the user has recognized any public key associated to him as authentic / verified.\n     * The key of the object should be a public key in hex-encoded spki format or its fingerprint (last 32 characters of\n     * the hex-encoded spki representation).\n     * If any of the keys from `unknownKeys` is completely missing from this object the key will be considered as\n     * unverified in this api instance (same as false). However, in this case the unverified status of the key won't be\n     * saved: next time that an api is instantiated, even if the storage was not reset sdk will ask again to verify the\n     * authenticity of that key.\n     */\n    readonly keyAuthenticity: { [fp: KeypairFingerprintV1String | SpkiHexString]: boolean }\n  }\n\n  export interface UnavailableKeyInfo {\n    /**\n     * The public key\n     */\n    readonly publicKey: SpkiHexString,\n    /**\n     * The algorithm of the keypair\n     */\n    readonly keyAlgorithm: RsaAlgorithm\n  }\n}\n\n/**\n * Allows to recover user keypairs using builtin recovery mechanisms.\n * This interface includes recovery methods that require some input from your application (e.g. a recovery key created from a different device).\n * Other recovery methods (such as transfer keys) are used automatically by the sdk when available and don't require any input from your application.\n */\nexport interface KeyPairRecoverer {\n  /**\n   * Recover a keypair using a recovery key created in the past using the {@link RecoveryApi.createRecoveryInfoForAvailableKeyPairs} method.\n   * @param recoveryKey the result of a past call to {@link RecoveryApi.createRecoveryInfoForAvailableKeyPairs}.\n   * @param autoDelete if true, the recovery data will be deleted from the server after it could be used successfully.\n   * This will prevent the recovery key from being used again.\n   * @return a recovery result, which, if successful, contains a map dataOwnerId -> publicKeySpki -> keyPair, where:\n   * - The `dataOwnerId` keys are the ids of the data owner which created the recovery data and his parents, if the recovery data contains also the\n   *   parents keys\n   * - The `publicKeySpki` keys are all recovered public key pairs for the data owner, in hex-encoded spki format (full, no fingerprint). Usually\n   *   these are all the keys if the recovery data was created after the latest key for the user.\n   * - The `keyPair` is the imported privateKey + publicKey.\n   */\n  recoverWithRecoveryKey(\n    recoveryKey: RecoveryDataKey,\n    autoDelete: boolean\n  ): Promise<RecoveryResult<{ [dataOwnerId: string]: { [publicKeySpki: SpkiHexString]: XRsaKeypair } }>>\n}"]}