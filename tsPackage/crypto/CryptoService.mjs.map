{"version":3,"file":"CryptoService.mjs","sourceRoot":"","sources":["../../tsSourcesProject/crypto/CryptoService.mts"],"names":[],"mappings":"AACA,MAAM,CAAN,IAAY,UAGX;AAHD,WAAY,UAAU;IACpB,iDAAY,CAAA;IACZ,iDAAY,CAAA;AACd,CAAC,EAHW,UAAU,KAAV,UAAU,QAGrB;AACD,MAAM,CAAN,IAAY,YAEX;AAFD,WAAY,YAAY;IACtB,2CAA2B,CAAA;AAC7B,CAAC,EAFW,YAAY,KAAZ,YAAY,QAEvB;AAsBD,MAAM,CAAN,IAAY,aAGX;AAHD,WAAY,aAAa;IACvB,0CAAyB,CAAA;IACzB,0CAAyB,CAAA;AAC3B,CAAC,EAHW,aAAa,KAAb,aAAa,QAGxB;AAaD,MAAM,CAAN,IAAY,UAGX;AAHD,WAAY,UAAU;IACpB,oDAAc,CAAA;IACd,oDAAc,CAAA;AAChB,CAAC,EAHW,UAAU,KAAV,UAAU,QAGrB;AACD,MAAM,CAAN,IAAY,sBAGX;AAHD,WAAY,sBAAsB;IAChC,uDAA6B,CAAA;IAC7B,2DAAiC,CAAA;AACnC,CAAC,EAHW,sBAAsB,KAAtB,sBAAsB,QAGjC;AACD,MAAM,CAAN,IAAY,qBAEX;AAFD,WAAY,qBAAqB;IAC/B,wDAA+B,CAAA;AACjC,CAAC,EAFW,qBAAqB,KAArB,qBAAqB,QAEhC","sourcesContent":["\nexport enum AesKeySize {\n  Aes128 = 128,\n  Aes256 = 256,\n}\nexport enum AesAlgorithm {\n  AesCbcPkcs7 = \"AesCbcPkcs7\"\n}\nexport interface XAesService {\n  generateKey(algorithm: AesAlgorithm, size: AesKeySize): Promise<XAesKey>;\n  exportKey(key: XAesKey): Promise<Int8Array>;\n  loadKey(algorithm: AesAlgorithm, bytes: Int8Array): Promise<XAesKey>;\n  encrypt(data: Int8Array, key: XAesKey, iv?: Int8Array): Promise<Int8Array>;\n  decrypt(ivAndEncryptedData: Int8Array, key: XAesKey): Promise<Int8Array>;\n}\nexport interface XAesKey {\n  readonly aesKey?: any;\n  readonly algorithm: string;\n}\nexport interface XCryptoService {\n  readonly aes: XAesService;\n  readonly digest: XDigestService;\n  readonly rsa: XRsaService;\n  readonly strongRandom: XStrongRandom;\n  readonly hmac: XHmacService;\n}\nexport interface XDigestService {\n  sha256(data: Int8Array): Promise<Int8Array>;\n}\nexport enum HmacAlgorithm {\n  HmacSha512 = \"HmacSha512\",\n  HmacSha256 = \"HmacSha256\",\n}\nexport interface XHmacService {\n  generateKey(algorithm: HmacAlgorithm, keySize?: number): Promise<XHmacKey>;\n  exportKey(key: XHmacKey): Promise<Int8Array>;\n  loadKey(algorithm: HmacAlgorithm, bytes: Int8Array): Promise<XHmacKey>;\n  sign(data: Int8Array, key: XHmacKey): Promise<Int8Array>;\n  verify(signature: Int8Array, data: Int8Array, key: XHmacKey): Promise<boolean>;\n}\nexport interface XHmacKey {\n  readonly hmacKey?: any;\n  readonly keySize: number;\n  readonly algorithm: string;\n}\nexport enum RsaKeySize {\n  Rsa2048 = 2048,\n  Rsa4096 = 4096,\n}\nexport enum RsaEncryptionAlgorithm {\n  OaepWithSha1 = \"OaepWithSha1\",\n  OaepWithSha256 = \"OaepWithSha256\"\n}\nexport enum RsaSignatureAlgorithm {\n  PssWithSha256 = \"PssWithSha256\"\n}\nexport type RsaAlgorithm = RsaEncryptionAlgorithm | RsaSignatureAlgorithm\nexport interface XRsaService {\n  generateKeyPair(algorithm: RsaAlgorithm, keySize: RsaKeySize): Promise<XRsaKeypair>;\n  exportPrivateKeyPkcs8(key: XPrivateRsaKey): Promise<Int8Array>;\n  exportPublicKeySpki(key: XPublicRsaKey): Promise<Int8Array>;\n  loadKeyPairPkcs8(algorithm: RsaAlgorithm, privateKeyPkcs8: Int8Array): Promise<XRsaKeypair>;\n  loadPrivateKeyPkcs8(algorithm: RsaAlgorithm, privateKeyPkcs8: Int8Array): Promise<XPrivateRsaKey>;\n  loadPublicKeySpki(algorithm: RsaAlgorithm, publicKeySpki: Int8Array): Promise<XPublicRsaKey>;\n  encrypt(data: Int8Array, publicKey: XPublicRsaKey): Promise<Int8Array>;\n  decrypt(data: Int8Array, privateKey: XPrivateRsaKey): Promise<Int8Array>;\n  sign(data: Int8Array, privateKey: XPrivateRsaKey): Promise<Int8Array>;\n  verifySignature(signature: Int8Array, data: Int8Array, publicKey: XPublicRsaKey): Promise<boolean>;\n  exportPrivateKeyJwk(key: XPrivateRsaKey): Promise<JsonWebKey>\n  exportPublicKeyJwk(key: XPublicRsaKey): Promise<JsonWebKey>\n  loadPrivateKeyJwk(privateKeyJwk: JsonWebKey): Promise<XPrivateRsaKey>\n  loadPublicKeyJwk(publicKeyJwk: JsonWebKey): Promise<XPublicRsaKey>\n}\nexport interface XRsaKeypair {\n  readonly private: XPrivateRsaKey;\n  readonly public: XPublicRsaKey;\n}\nexport interface XPrivateRsaKey {\n  readonly privateKey?: any;\n  readonly algorithm: string;\n}\nexport interface XPublicRsaKey {\n  readonly publicKey?: any;\n  readonly algorithm: string;\n}\nexport interface XStrongRandom {\n  randomBytes(length: number): Int8Array;\n  randomUUID(): string;\n}"]}