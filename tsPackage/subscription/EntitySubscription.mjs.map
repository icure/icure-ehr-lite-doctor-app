{"version":3,"file":"EntitySubscription.mjs","sourceRoot":"","sources":["../../tsSourcesProject/subscription/EntitySubscription.mts"],"names":[],"mappings":"","sourcesContent":["import {Identifiable} from \"../model/base/Identifiable.mjs\";\nimport {EntitySubscriptionCloseReason} from \"./EntitySubscriptionCloseReason.mjs\";\nimport {EntitySubscriptionEvent} from \"./EntitySubscriptionEvent.mjs\";\nimport {CancellablePromise} from \"../utils/CancellablePromise.mjs\";\n\nexport interface EntitySubscription<E extends Identifiable<string>> {\n  /**\n   * Closes the subscription. A closed subscription will not receive any new events, but any existing event may still\n   * be consumed after closing.\n   */\n  close(): Promise<void>\n\n  /**\n   * If the subscription is permanently closed. Even if this is true there may still be some unconsumed events\n   */\n  readonly isClosed: Boolean\n\n  /**\n   * If the subscription is closed the reason for closure, null otherwise. Even if this is not null there may still be\n   * some unconsumed events\n   */\n  readonly closeReason: EntitySubscriptionCloseReason | null\n\n  /**\n   * Consume the next event in the subscription event queue or null if there is currently no event. If the subscription is\n   * closed you can still retrieved any unconsumed event, but no new event will be added to the queue.\n   */\n  getEvent(): EntitySubscriptionEvent<E> | null\n\n  /**\n   * Waits for the next event in the subscription event queue and consumes it, or return null if no new event is produced\n   * within the provided timeout or if the subscription gets closed while waiting.\n   */\n  waitForEvent(timeoutMs: number): CancellablePromise<EntitySubscriptionEvent<E> | null>\n}"]}