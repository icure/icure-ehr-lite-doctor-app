import {
  enumEntries20mr21zbe3az4 as enumEntries,
  Unit_instanceat14thlj150z as Unit_instance,
  Enum3alwj03lh1n41 as Enum,
  protoOf180f3jzyo7rfj as protoOf,
  initMetadataForClassbxx6q50dy2s7 as initMetadataForClass,
  VOID7hggqo3abtya as VOID,
  initMetadataForInterface1egvbzx539z91 as initMetadataForInterface,
  singleOrNull21olsob387p54 as singleOrNull,
  toString1pkumu07cwy4m as toString,
  IllegalArgumentException_init_$Create$sfel9vrfa7w2 as IllegalArgumentException_init_$Create$,
  getStringHashCode26igk1bx568vk as getStringHashCode,
  getBooleanHashCode1bbj3u6b3v0a7 as getBooleanHashCode,
  hashCodeq5arwsb9dgti as hashCode,
  THROW_CCE2g6jy02ryeudk as THROW_CCE,
  equals2au1ep9vhcato as equals,
  initMetadataForObject1cxne3s9w65el as initMetadataForObject,
  initMetadataForCompanion1wyw17z38v6ac as initMetadataForCompanion,
  CoroutineImpl2sn3kjnwmfr10 as CoroutineImpl,
  get_COROUTINE_SUSPENDED3ujt3p13qm4iy as get_COROUTINE_SUSPENDED,
  initMetadataForCoroutine1i7lbatuf5bnt as initMetadataForCoroutine,
  _UByteArray___init__impl__ip4y9n3sp5zyufbcv0v as _UByteArray___init__impl__ip4y9n,
  UByteArray__get_impl_t5f3hv1encpe8trq9zx as UByteArray__get_impl_t5f3hv,
  _UByte___init__impl__g9hnc43i8t7wecfr79w as _UByte___init__impl__g9hnc4,
  _UByte___get_data__impl__jof9qr1jhbnu489etgz as _UByte___get_data__impl__jof9qr,
  toByte4i43936u611k as toByte,
  UByteArray__set_impl_jvcicn11526muxjy7z7 as UByteArray__set_impl_jvcicn,
  Exceptiondt2hlxn7j7vw as Exception,
  primitiveArrayConcatwxgknw08pmlb as primitiveArrayConcat,
  drop15np6gvzvspod as drop,
  toByteArray3caw0hip00os as toByteArray,
  noWhenBranchMatchedException2a6r7ubxgky5j as noWhenBranchMatchedException,
  Long2qws0ah9gnpki as Long,
  toLongw1zpgk99d84b as toLong,
  _Char___init__impl__6a9atx367vrx0avsvbg as _Char___init__impl__6a9atx,
  charArrayOf27f4r3dozbrk1 as charArrayOf,
  split3d3yeauc4rm2n as split,
  collectionSizeOrDefault36dulx8yinfqm as collectionSizeOrDefault,
  ArrayList_init_$Create$3m1kyiqequwm5 as ArrayList_init_$Create$,
  toInt2q8uldh7sc951 as toInt,
  drop3na99dw9feawf as drop_0,
  ArrayList_init_$Create$2rimpp4x9tjd3 as ArrayList_init_$Create$_0,
  addAll1k27qatfgp3k5 as addAll,
  plus2k46aly60owrn as plus,
  copyOfRange3alro60z4hhf8 as copyOfRange,
  mutableListOf6oorvk2mtdmp as mutableListOf,
  joinToString1cxrrlmo0chqs as joinToString,
  first1cs6gg5jrulfl as first,
  until1jbpn0z3f8lbg as until,
  sliceArray2hu2ljigibgmi as sliceArray,
  get_lastIndexld83bqhfgcdd as get_lastIndex,
  charSequenceGet1vxk1y5n17t1z as charSequenceGet,
  Paire9pteg33gng7 as Pair,
  setOf1u3mizs95ngxo as setOf,
  isInterface3d6p8outrmvmk as isInterface,
  listOf1jh22dvmctj1r as listOf,
  charSequenceLength3278n89t01tmv as charSequenceLength,
  last2n4gf5az1lkn4 as last,
  getOrNull3idcogs0ybps as getOrNull,
  charArray2ujmm1qusno00 as charArray,
  fillArrayVali8eppxapiek4 as fillArrayVal,
  concatToString3cxf0c1gqonpo as concatToString,
  longArray288a0fctlmjmj as longArray,
  numberToChar93r9buh19yek as numberToChar,
  indexOf1xbs558u7wr52 as indexOf,
  getOrNullef5jbxih7r4f as getOrNull_0,
  Companion_getInstance1ree0imtfybva as Companion_getInstance,
  _UByteArray___get_storage__impl__d4kctt1v2w0kp012p35 as _UByteArray___get_storage__impl__d4kctt,
  toHexString5bhtjxqec7ow as toHexString,
  hexToByteArrayj26yk4970vc7 as hexToByteArray,
  to2cs3ny02qtbcb as to,
  json3n35pf5np6si4 as json,
  AssertionError_init_$Create$3o4avq23988f3 as AssertionError_init_$Create$,
  isArray1hxjqtqy632bc as isArray,
  toSet1glep2u1u9tcb as toSet,
  copyToArray2j022khrow2yi as copyToArray,
  toTypedArray3sl1vhn8ifta0 as toTypedArray,
  defineProp3hxgpk2knu2px as defineProp,
  NoSuchElementException_init_$Create$1admdzgt61c19 as NoSuchElementException_init_$Create$,
  initMetadataForLambda3af3he42mmnh as initMetadataForLambda,
  arrayCopytctsywo3h7gj as arrayCopy,
  IllegalStateException_init_$Create$1nm9y6jd3c9iy as IllegalStateException_init_$Create$,
  KProperty02ce7r476m8633 as KProperty0,
  getPropertyCallableRef1ajb9in178r5r as getPropertyCallableRef,
  lazy2hsh8ze7j6ikd as lazy,
  Exception_init_$Init$3c1h61we8oiuv as Exception_init_$Init$,
  captureStack1fzi4aczwc4hg as captureStack,
} from './kotlin-kotlin-stdlib.mjs';
import {
  Buffergs925ekssbch as Buffer,
  writeString33ca4btrgctw7 as writeString,
  readByteArray1ri21h2rciakw as readByteArray,
} from './kotlinx-io-kotlinx-io-core.mjs';
import {
  await24mygle6x7vn5 as await_0,
  CoroutineScopefcb5f5dwqcas as CoroutineScope,
  GlobalScope_instance3m5vaygder2s9 as GlobalScope_instance,
  promise1ky6tawqaxbt4 as promise,
} from './kotlinx-coroutines-core.mjs';
//region block: imports
var imul = Math.imul;
//endregion
//region block: pre-declaration
initMetadataForClass(KeySize, 'KeySize', VOID, Enum);
function generateKey$default(algorithm, size, $completion, $super) {
  size = size === VOID ? KeySize_Aes256_getInstance() : size;
  return $super === VOID ? this.p5k(algorithm, size, $completion) : $super.p5k.call(this, algorithm, size, $completion);
}
function encrypt$default(data, key, iv, $completion, $super) {
  iv = iv === VOID ? null : iv;
  return $super === VOID ? this.t5k(data, key, iv, $completion) : $super.t5k.call(this, data, key, iv, $completion);
}
initMetadataForInterface(AesService, 'AesService', VOID, VOID, VOID, [2, 1, 3]);
initMetadataForInterface(CryptoService, 'CryptoService');
function generateKey$default_0(algorithm, keySize, $completion, $super) {
  keySize = keySize === VOID ? null : keySize;
  return $super === VOID ? this.b5l(algorithm, keySize, $completion) : $super.b5l.call(this, algorithm, keySize, $completion);
}
initMetadataForInterface(HmacService, 'HmacService', VOID, VOID, VOID, [2, 1, 3]);
initMetadataForClass(PrivateRsaKeyJwk, 'PrivateRsaKeyJwk');
initMetadataForClass(PublicRsaKeyJwk, 'PublicRsaKeyJwk');
initMetadataForObject(CbcWithPkcs7Padding, 'CbcWithPkcs7Padding');
initMetadataForCompanion(Companion);
initMetadataForObject(HmacSha512, 'HmacSha512');
initMetadataForObject(HmacSha256, 'HmacSha256');
initMetadataForCompanion(Companion_0);
initMetadataForCompanion(Companion_1);
initMetadataForInterface(RsaEncryptionAlgorithm, 'RsaEncryptionAlgorithm');
initMetadataForObject(OaepWithSha1, 'OaepWithSha1', VOID, VOID, [RsaEncryptionAlgorithm]);
initMetadataForObject(OaepWithSha256, 'OaepWithSha256', VOID, VOID, [RsaEncryptionAlgorithm]);
initMetadataForCompanion(Companion_2);
initMetadataForInterface(RsaSignatureAlgorithm, 'RsaSignatureAlgorithm');
initMetadataForObject(PssWithSha256, 'PssWithSha256', VOID, VOID, [RsaSignatureAlgorithm]);
initMetadataForCompanion(Companion_3);
initMetadataForClass(RsaKeypair, 'RsaKeypair');
initMetadataForClass(KeySize_0, 'KeySize', VOID, Enum);
initMetadataForCoroutine($exportPrivateKeyJwkCOROUTINE$0, CoroutineImpl);
initMetadataForCoroutine($exportPublicKeyJwkCOROUTINE$1, CoroutineImpl);
function exportPrivateKeyJwk(key, $completion) {
  var tmp = new $exportPrivateKeyJwkCOROUTINE$0(this, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
}
function exportPublicKeyJwk(key, $completion) {
  var tmp = new $exportPublicKeyJwkCOROUTINE$1(this, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
}
function loadPrivateKeyJwk(algorithm, privateKeyJwk, $completion) {
  // Inline function 'kotlin.require' call
  // Inline function 'kotlin.contracts.contract' call
  if (!(privateKeyJwk.h5l_1 === algorithm.o5m())) {
    // Inline function 'com.icure.kryptom.crypto.RsaService.loadPrivateKeyJwk.<anonymous>' call
    var message = 'Algorithm of JWK does not match provided algorithm - ' + privateKeyJwk.h5l_1 + ' != ' + algorithm.o5m();
    throw IllegalArgumentException_init_$Create$(toString(message));
  }
  return this.k5o(algorithm, AsnToJwkConverter_instance.m5o(privateKeyJwk), $completion);
}
function loadPublicKeyJwk(algorithm, publicKeyJwk, $completion) {
  // Inline function 'kotlin.require' call
  // Inline function 'kotlin.contracts.contract' call
  if (!(publicKeyJwk.t5l_1 === algorithm.o5m())) {
    // Inline function 'com.icure.kryptom.crypto.RsaService.loadPublicKeyJwk.<anonymous>' call
    var message = 'Algorithm of JWK does not match provided algorithm - ' + publicKeyJwk.t5l_1 + ' != ' + algorithm.o5m();
    throw IllegalArgumentException_init_$Create$(toString(message));
  }
  return this.n5o(algorithm, AsnToJwkConverter_instance.p5o(publicKeyJwk), $completion);
}
initMetadataForInterface(RsaService, 'RsaService', VOID, VOID, VOID, [2, 1, 3]);
function randomBytes(length) {
  // Inline function 'kotlin.also' call
  var this_0 = new Int8Array(length);
  // Inline function 'kotlin.contracts.contract' call
  // Inline function 'com.icure.kryptom.crypto.StrongRandom.randomBytes.<anonymous>' call
  this.v5o(this_0);
  return this_0;
}
function randomUUID() {
  // Inline function 'kotlin.collections.toUByteArray' call
  // Inline function 'kotlin.collections.copyOf' call
  // Inline function 'kotlin.js.asDynamic' call
  var tmp$ret$1 = this.u5o(16).slice();
  var bytes = _UByteArray___init__impl__ip4y9n(tmp$ret$1);
  // Inline function 'kotlin.UByte.or' call
  // Inline function 'kotlin.UByte.and' call
  var this_0 = UByteArray__get_impl_t5f3hv(bytes, 6);
  var other = _UByte___init__impl__g9hnc4(15);
  // Inline function 'kotlin.experimental.and' call
  var this_1 = _UByte___get_data__impl__jof9qr(this_0);
  var other_0 = _UByte___get_data__impl__jof9qr(other);
  var tmp$ret$3 = toByte(this_1 & other_0);
  var this_2 = _UByte___init__impl__g9hnc4(tmp$ret$3);
  var other_1 = _UByte___init__impl__g9hnc4(64);
  // Inline function 'kotlin.experimental.or' call
  var this_3 = _UByte___get_data__impl__jof9qr(this_2);
  var other_2 = _UByte___get_data__impl__jof9qr(other_1);
  var tmp$ret$5 = toByte(this_3 | other_2);
  var tmp$ret$6 = _UByte___init__impl__g9hnc4(tmp$ret$5);
  UByteArray__set_impl_jvcicn(bytes, 6, tmp$ret$6);
  // Inline function 'kotlin.UByte.or' call
  // Inline function 'kotlin.UByte.and' call
  var this_4 = UByteArray__get_impl_t5f3hv(bytes, 8);
  var other_3 = _UByte___init__impl__g9hnc4(63);
  // Inline function 'kotlin.experimental.and' call
  var this_5 = _UByte___get_data__impl__jof9qr(this_4);
  var other_4 = _UByte___get_data__impl__jof9qr(other_3);
  var tmp$ret$7 = toByte(this_5 & other_4);
  var this_6 = _UByte___init__impl__g9hnc4(tmp$ret$7);
  var other_5 = _UByte___init__impl__g9hnc4(-128);
  // Inline function 'kotlin.experimental.or' call
  var this_7 = _UByte___get_data__impl__jof9qr(this_6);
  var other_6 = _UByte___get_data__impl__jof9qr(other_5);
  var tmp$ret$9 = toByte(this_7 | other_6);
  var tmp$ret$10 = _UByte___init__impl__g9hnc4(tmp$ret$9);
  UByteArray__set_impl_jvcicn(bytes, 8, tmp$ret$10);
  var s = toHexString_0(bytes);
  // Inline function 'kotlin.text.substring' call
  // Inline function 'kotlin.js.asDynamic' call
  var tmp = s.substring(0, 8);
  // Inline function 'kotlin.text.substring' call
  // Inline function 'kotlin.js.asDynamic' call
  var tmp_0 = s.substring(8, 12);
  // Inline function 'kotlin.text.substring' call
  // Inline function 'kotlin.js.asDynamic' call
  var tmp_1 = s.substring(12, 16);
  // Inline function 'kotlin.text.substring' call
  // Inline function 'kotlin.js.asDynamic' call
  var tmp_2 = s.substring(16, 20);
  // Inline function 'kotlin.text.substring' call
  // Inline function 'kotlin.js.asDynamic' call
  return tmp + '-' + tmp_0 + '-' + tmp_1 + '-' + tmp_2 + '-' + s.substring(20);
}
initMetadataForInterface(StrongRandom, 'StrongRandom');
function getTag() {
  var tmp;
  if (this instanceof Asn1Integer) {
    tmp = 2;
  } else {
    if (this instanceof Asn1OctetString) {
      tmp = 4;
    } else {
      if (this instanceof Asn1Sequence) {
        tmp = 48;
      } else {
        if (this instanceof Asn1Enumerated) {
          tmp = 10;
        } else {
          if (this instanceof Asn1Null) {
            tmp = 5;
          } else {
            if (this instanceof Asn1Oid) {
              tmp = 6;
            } else {
              if (this instanceof Asn1Boolean) {
                tmp = 1;
              } else {
                if (this instanceof Asn1BitString) {
                  tmp = 3;
                } else {
                  noWhenBranchMatchedException();
                }
              }
            }
          }
        }
      }
    }
  }
  return tmp;
}
initMetadataForInterface(Asn1Object, 'Asn1Object');
initMetadataForClass(Asn1Integer, 'Asn1Integer', VOID, VOID, [Asn1Object]);
initMetadataForClass(Asn1OctetString, 'Asn1OctetString', VOID, VOID, [Asn1Object]);
initMetadataForClass(Asn1Sequence, 'Asn1Sequence', VOID, VOID, [Asn1Object]);
initMetadataForClass(Asn1Enumerated, 'Asn1Enumerated', VOID, VOID, [Asn1Object]);
initMetadataForClass(Asn1Null, 'Asn1Null', Asn1Null, VOID, [Asn1Object]);
initMetadataForClass(Asn1Oid, 'Asn1Oid', VOID, VOID, [Asn1Object]);
initMetadataForClass(Asn1Boolean, 'Asn1Boolean', VOID, VOID, [Asn1Object]);
initMetadataForClass(Asn1BitString, 'Asn1BitString', VOID, VOID, [Asn1Object]);
initMetadataForObject(AsnUtils, 'AsnUtils');
initMetadataForObject(AsnToJwkConverter, 'AsnToJwkConverter');
initMetadataForClass(defaultCryptoService$1, VOID, VOID, VOID, [CryptoService]);
initMetadataForCoroutine($generateKeyCOROUTINE$2, CoroutineImpl);
initMetadataForCoroutine($exportKeyCOROUTINE$3, CoroutineImpl);
initMetadataForCoroutine($loadKeyCOROUTINE$4, CoroutineImpl);
initMetadataForCoroutine($encryptCOROUTINE$5, CoroutineImpl);
initMetadataForCoroutine($decryptCOROUTINE$6, CoroutineImpl);
initMetadataForObject(JsAesService, 'JsAesService', VOID, VOID, [AesService], [2, 1, 3]);
initMetadataForCoroutine($sha256COROUTINE$7, CoroutineImpl);
initMetadataForCoroutine($sha512COROUTINE$8, CoroutineImpl);
initMetadataForObject(JsDigestService, 'JsDigestService', VOID, VOID, VOID, [1]);
initMetadataForCoroutine($generateKeyCOROUTINE$9, CoroutineImpl);
initMetadataForCoroutine($exportKeyCOROUTINE$10, CoroutineImpl);
initMetadataForCoroutine($exportRawKeyCOROUTINE$11, CoroutineImpl);
initMetadataForCoroutine($loadKeyCOROUTINE$12, CoroutineImpl);
initMetadataForCoroutine($signCOROUTINE$13, CoroutineImpl);
initMetadataForObject(JsHmacService, 'JsHmacService', VOID, VOID, [HmacService], [2, 1, 3]);
initMetadataForCoroutine($generateKeyPairCOROUTINE$14, CoroutineImpl);
initMetadataForCoroutine($exportPrivateKeyPkcs8COROUTINE$15, CoroutineImpl);
initMetadataForCoroutine($exportPublicKeySpkiCOROUTINE$16, CoroutineImpl);
initMetadataForCoroutine($loadKeyPairPkcs8COROUTINE$17, CoroutineImpl);
initMetadataForCoroutine($loadPrivateKeyPkcs8COROUTINE$18, CoroutineImpl);
initMetadataForCoroutine($loadPublicKeySpkiCOROUTINE$19, CoroutineImpl);
initMetadataForCoroutine($encryptCOROUTINE$20, CoroutineImpl);
initMetadataForCoroutine($decryptCOROUTINE$21, CoroutineImpl);
initMetadataForCoroutine($signCOROUTINE$22, CoroutineImpl);
initMetadataForCoroutine($exportPrivateKeyJwkCOROUTINE$23, CoroutineImpl);
initMetadataForCoroutine($exportPublicKeyJwkCOROUTINE$24, CoroutineImpl);
initMetadataForCoroutine($loadPrivateKeyJwkCOROUTINE$25, CoroutineImpl);
initMetadataForCoroutine($loadPublicKeyJwkCOROUTINE$26, CoroutineImpl);
initMetadataForObject(JsRsaService, 'JsRsaService', VOID, VOID, [RsaService], [2, 1, 3]);
initMetadataForObject(JsStrongRandom, 'JsStrongRandom', VOID, VOID, [StrongRandom]);
initMetadataForClass(AesKey, 'AesKey');
initMetadataForClass(HmacKey, 'HmacKey');
initMetadataForClass(PrivateRsaKey, 'PrivateRsaKey');
initMetadataForClass(PublicRsaKey, 'PublicRsaKey');
initMetadataForClass(XServiceAdapter, 'XServiceAdapter');
initMetadataForClass(ServiceAdapter, 'ServiceAdapter', VOID, VOID, [CryptoService]);
initMetadataForLambda(XAesServiceAdapter$generateKey$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XAesServiceAdapter$exportKey$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XAesServiceAdapter$loadKey$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XAesServiceAdapter$encrypt$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XAesServiceAdapter$decrypt$slambda, CoroutineImpl, VOID, [1]);
initMetadataForClass(XAesServiceAdapter, 'XAesServiceAdapter');
initMetadataForLambda(XDigestServiceAdapter$sha256$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XDigestServiceAdapter$sha512$slambda, CoroutineImpl, VOID, [1]);
initMetadataForClass(XDigestServiceAdapter, 'XDigestServiceAdapter');
initMetadataForLambda(XRsaServiceAdapter$generateKeyPair$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$exportPrivateKeyPkcs8$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$exportPublicKeySpki$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$loadKeyPairPkcs8$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$loadPrivateKeyPkcs8$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$loadPublicKeySpki$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$encrypt$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$decrypt$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$sign$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$verifySignature$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$exportPrivateKeyJwk$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$exportPublicKeyJwk$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$loadPrivateKeyJwk$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XRsaServiceAdapter$loadPublicKeyJwk$slambda, CoroutineImpl, VOID, [1]);
initMetadataForClass(XRsaServiceAdapter, 'XRsaServiceAdapter');
initMetadataForClass(XStrongRandomAdapter, 'XStrongRandomAdapter');
initMetadataForLambda(XHmacServiceAdapter$generateKey$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XHmacServiceAdapter$exportKey$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XHmacServiceAdapter$loadKey$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XHmacServiceAdapter$sign$slambda, CoroutineImpl, VOID, [1]);
initMetadataForLambda(XHmacServiceAdapter$verify$slambda, CoroutineImpl, VOID, [1]);
initMetadataForClass(XHmacServiceAdapter, 'XHmacServiceAdapter');
initMetadataForCoroutine($generateKeyCOROUTINE$27, CoroutineImpl);
initMetadataForCoroutine($loadKeyCOROUTINE$28, CoroutineImpl);
initMetadataForClass(AesServiceAdapter, 'AesServiceAdapter', VOID, VOID, [AesService], [2, 1, 3]);
initMetadataForClass(DigestServiceAdapter, 'DigestServiceAdapter', VOID, VOID, VOID, [1]);
initMetadataForCoroutine($generateKeyPairCOROUTINE$29, CoroutineImpl);
initMetadataForCoroutine($loadPrivateKeyPkcs8COROUTINE$30, CoroutineImpl);
initMetadataForCoroutine($loadKeyPairPkcs8COROUTINE$31, CoroutineImpl);
initMetadataForCoroutine($loadPublicKeySpkiCOROUTINE$32, CoroutineImpl);
initMetadataForCoroutine($exportPrivateKeyJwkCOROUTINE$33, CoroutineImpl);
initMetadataForCoroutine($exportPublicKeyJwkCOROUTINE$34, CoroutineImpl);
initMetadataForCoroutine($loadPrivateKeyJwkCOROUTINE$35, CoroutineImpl);
initMetadataForCoroutine($loadPublicKeyJwkCOROUTINE$36, CoroutineImpl);
initMetadataForClass(RsaServiceAdapter, 'RsaServiceAdapter', VOID, VOID, [RsaService], [2, 1, 3]);
initMetadataForClass(StrongRandomAdapter, 'StrongRandomAdapter', VOID, VOID, [StrongRandom]);
initMetadataForCoroutine($generateKeyCOROUTINE$37, CoroutineImpl);
initMetadataForCoroutine($loadKeyCOROUTINE$38, CoroutineImpl);
initMetadataForClass(HmacServiceAdapter, 'HmacServiceAdapter', VOID, VOID, [HmacService], [2, 1, 3]);
initMetadataForClass(DynamicParser, 'DynamicParser');
initMetadataForClass(PlatformMethodException, 'PlatformMethodException', VOID, Exception);
//endregion
var KeySize_Aes128_instance;
var KeySize_Aes256_instance;
function values() {
  return [KeySize_Aes128_getInstance(), KeySize_Aes256_getInstance()];
}
function get_entries() {
  if ($ENTRIES == null)
    $ENTRIES = enumEntries(values());
  return $ENTRIES;
}
var KeySize_entriesInitialized;
function KeySize_initEntries() {
  if (KeySize_entriesInitialized)
    return Unit_instance;
  KeySize_entriesInitialized = true;
  KeySize_Aes128_instance = new KeySize('Aes128', 0, 128);
  KeySize_Aes256_instance = new KeySize('Aes256', 1, 256);
}
var $ENTRIES;
function KeySize(name, ordinal, bitSize) {
  Enum.call(this, name, ordinal);
  this.o5k_1 = bitSize;
}
function KeySize_Aes128_getInstance() {
  KeySize_initEntries();
  return KeySize_Aes128_instance;
}
function KeySize_Aes256_getInstance() {
  KeySize_initEntries();
  return KeySize_Aes256_instance;
}
function AesService() {
}
function CryptoService() {
}
function HmacService() {
}
function PrivateRsaKeyJwk(alg, d, dp, dq, e, ext, key_ops, n, p, q, qi) {
  this.h5l_1 = alg;
  this.i5l_1 = d;
  this.j5l_1 = dp;
  this.k5l_1 = dq;
  this.l5l_1 = e;
  this.m5l_1 = ext;
  this.n5l_1 = key_ops;
  this.o5l_1 = n;
  this.p5l_1 = p;
  this.q5l_1 = q;
  this.r5l_1 = qi;
  this.s5l_1 = 'RSA';
  // Inline function 'kotlin.require' call
  // Inline function 'kotlin.contracts.contract' call
  if (!(singleOrNull(this.n5l_1) === 'sign' || singleOrNull(this.n5l_1) === 'decrypt')) {
    // Inline function 'com.icure.kryptom.crypto.PrivateRsaKeyJwk.<anonymous>' call
    var message = 'Invalid key_ops for private key - ' + toString(this.n5l_1);
    throw IllegalArgumentException_init_$Create$(toString(message));
  }
}
protoOf(PrivateRsaKeyJwk).toString = function () {
  return 'PrivateRsaKeyJwk(alg=' + this.h5l_1 + ', d=' + this.i5l_1 + ', dp=' + this.j5l_1 + ', dq=' + this.k5l_1 + ', e=' + this.l5l_1 + ', ext=' + this.m5l_1 + ', key_ops=' + toString(this.n5l_1) + ', n=' + this.o5l_1 + ', p=' + this.p5l_1 + ', q=' + this.q5l_1 + ', qi=' + this.r5l_1 + ')';
};
protoOf(PrivateRsaKeyJwk).hashCode = function () {
  var result = getStringHashCode(this.h5l_1);
  result = imul(result, 31) + getStringHashCode(this.i5l_1) | 0;
  result = imul(result, 31) + getStringHashCode(this.j5l_1) | 0;
  result = imul(result, 31) + getStringHashCode(this.k5l_1) | 0;
  result = imul(result, 31) + getStringHashCode(this.l5l_1) | 0;
  result = imul(result, 31) + getBooleanHashCode(this.m5l_1) | 0;
  result = imul(result, 31) + hashCode(this.n5l_1) | 0;
  result = imul(result, 31) + getStringHashCode(this.o5l_1) | 0;
  result = imul(result, 31) + getStringHashCode(this.p5l_1) | 0;
  result = imul(result, 31) + getStringHashCode(this.q5l_1) | 0;
  result = imul(result, 31) + getStringHashCode(this.r5l_1) | 0;
  return result;
};
protoOf(PrivateRsaKeyJwk).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof PrivateRsaKeyJwk))
    return false;
  var tmp0_other_with_cast = other instanceof PrivateRsaKeyJwk ? other : THROW_CCE();
  if (!(this.h5l_1 === tmp0_other_with_cast.h5l_1))
    return false;
  if (!(this.i5l_1 === tmp0_other_with_cast.i5l_1))
    return false;
  if (!(this.j5l_1 === tmp0_other_with_cast.j5l_1))
    return false;
  if (!(this.k5l_1 === tmp0_other_with_cast.k5l_1))
    return false;
  if (!(this.l5l_1 === tmp0_other_with_cast.l5l_1))
    return false;
  if (!(this.m5l_1 === tmp0_other_with_cast.m5l_1))
    return false;
  if (!equals(this.n5l_1, tmp0_other_with_cast.n5l_1))
    return false;
  if (!(this.o5l_1 === tmp0_other_with_cast.o5l_1))
    return false;
  if (!(this.p5l_1 === tmp0_other_with_cast.p5l_1))
    return false;
  if (!(this.q5l_1 === tmp0_other_with_cast.q5l_1))
    return false;
  if (!(this.r5l_1 === tmp0_other_with_cast.r5l_1))
    return false;
  return true;
};
function PublicRsaKeyJwk(alg, e, ext, key_ops, n) {
  this.t5l_1 = alg;
  this.u5l_1 = e;
  this.v5l_1 = ext;
  this.w5l_1 = key_ops;
  this.x5l_1 = n;
  this.y5l_1 = 'RSA';
  // Inline function 'kotlin.require' call
  // Inline function 'kotlin.contracts.contract' call
  if (!(singleOrNull(this.w5l_1) === 'verify' || singleOrNull(this.w5l_1) === 'encrypt')) {
    // Inline function 'com.icure.kryptom.crypto.PublicRsaKeyJwk.<anonymous>' call
    var message = 'Invalid key_ops for public key - ' + toString(this.w5l_1);
    throw IllegalArgumentException_init_$Create$(toString(message));
  }
}
protoOf(PublicRsaKeyJwk).toString = function () {
  return 'PublicRsaKeyJwk(alg=' + this.t5l_1 + ', e=' + this.u5l_1 + ', ext=' + this.v5l_1 + ', key_ops=' + toString(this.w5l_1) + ', n=' + this.x5l_1 + ')';
};
protoOf(PublicRsaKeyJwk).hashCode = function () {
  var result = getStringHashCode(this.t5l_1);
  result = imul(result, 31) + getStringHashCode(this.u5l_1) | 0;
  result = imul(result, 31) + getBooleanHashCode(this.v5l_1) | 0;
  result = imul(result, 31) + hashCode(this.w5l_1) | 0;
  result = imul(result, 31) + getStringHashCode(this.x5l_1) | 0;
  return result;
};
protoOf(PublicRsaKeyJwk).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof PublicRsaKeyJwk))
    return false;
  var tmp0_other_with_cast = other instanceof PublicRsaKeyJwk ? other : THROW_CCE();
  if (!(this.t5l_1 === tmp0_other_with_cast.t5l_1))
    return false;
  if (!(this.u5l_1 === tmp0_other_with_cast.u5l_1))
    return false;
  if (!(this.v5l_1 === tmp0_other_with_cast.v5l_1))
    return false;
  if (!equals(this.w5l_1, tmp0_other_with_cast.w5l_1))
    return false;
  if (!(this.x5l_1 === tmp0_other_with_cast.x5l_1))
    return false;
  return true;
};
function CbcWithPkcs7Padding() {
  this.z5l_1 = 'AesCbcPkcs7';
}
protoOf(CbcWithPkcs7Padding).a5m = function () {
  return this.z5l_1;
};
protoOf(CbcWithPkcs7Padding).toString = function () {
  return 'CbcWithPkcs7Padding';
};
protoOf(CbcWithPkcs7Padding).hashCode = function () {
  return 492625607;
};
protoOf(CbcWithPkcs7Padding).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof CbcWithPkcs7Padding))
    return false;
  other instanceof CbcWithPkcs7Padding || THROW_CCE();
  return true;
};
var CbcWithPkcs7Padding_instance;
function CbcWithPkcs7Padding_getInstance() {
  return CbcWithPkcs7Padding_instance;
}
function Companion() {
}
protoOf(Companion).b5m = function (identifier) {
  var tmp;
  if (identifier === 'AesCbcPkcs7') {
    tmp = CbcWithPkcs7Padding_instance;
  } else {
    throw IllegalArgumentException_init_$Create$('Unknown aes algorithm ' + identifier);
  }
  return tmp;
};
var Companion_instance;
function Companion_getInstance_0() {
  return Companion_instance;
}
function HmacSha512() {
  this.c5m_1 = 128;
  this.d5m_1 = 64;
  this.e5m_1 = 64;
  this.f5m_1 = 'HmacSha512';
}
protoOf(HmacSha512).g5m = function () {
  return this.c5m_1;
};
protoOf(HmacSha512).h5m = function () {
  return this.d5m_1;
};
protoOf(HmacSha512).a5m = function () {
  return this.f5m_1;
};
protoOf(HmacSha512).toString = function () {
  return 'HmacSha512';
};
protoOf(HmacSha512).hashCode = function () {
  return 1907873853;
};
protoOf(HmacSha512).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof HmacSha512))
    return false;
  other instanceof HmacSha512 || THROW_CCE();
  return true;
};
var HmacSha512_instance;
function HmacSha512_getInstance() {
  return HmacSha512_instance;
}
function HmacSha256() {
  this.i5m_1 = 64;
  this.j5m_1 = 32;
  this.k5m_1 = 32;
  this.l5m_1 = 'HmacSha256';
}
protoOf(HmacSha256).g5m = function () {
  return this.i5m_1;
};
protoOf(HmacSha256).h5m = function () {
  return this.j5m_1;
};
protoOf(HmacSha256).a5m = function () {
  return this.l5m_1;
};
protoOf(HmacSha256).toString = function () {
  return 'HmacSha256';
};
protoOf(HmacSha256).hashCode = function () {
  return 1907871098;
};
protoOf(HmacSha256).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof HmacSha256))
    return false;
  other instanceof HmacSha256 || THROW_CCE();
  return true;
};
var HmacSha256_instance;
function HmacSha256_getInstance() {
  return HmacSha256_instance;
}
function Companion_0() {
}
protoOf(Companion_0).b5m = function (identifier) {
  var tmp;
  switch (identifier) {
    case 'HmacSha512':
      tmp = HmacSha512_instance;
      break;
    case 'HmacSha256':
      tmp = HmacSha256_instance;
      break;
    default:
      throw IllegalArgumentException_init_$Create$('Unknown hmac algorithm ' + identifier);
  }
  return tmp;
};
var Companion_instance_0;
function Companion_getInstance_1() {
  return Companion_instance_0;
}
function Companion_1() {
}
protoOf(Companion_1).b5m = function (identifier) {
  var tmp;
  switch (identifier) {
    case 'OaepWithSha1':
      tmp = OaepWithSha1_instance;
      break;
    case 'OaepWithSha256':
      tmp = OaepWithSha256_instance;
      break;
    default:
      throw IllegalArgumentException_init_$Create$('Unknown rsa encryption algorithm ' + identifier);
  }
  return tmp;
};
var Companion_instance_1;
function Companion_getInstance_2() {
  return Companion_instance_1;
}
function OaepWithSha1() {
  this.m5m_1 = 'OaepWithSha1';
  this.n5m_1 = 'RSA-OAEP';
}
protoOf(OaepWithSha1).a5m = function () {
  return this.m5m_1;
};
protoOf(OaepWithSha1).o5m = function () {
  return this.n5m_1;
};
protoOf(OaepWithSha1).toString = function () {
  return 'OaepWithSha1';
};
protoOf(OaepWithSha1).hashCode = function () {
  return 2101932433;
};
protoOf(OaepWithSha1).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof OaepWithSha1))
    return false;
  other instanceof OaepWithSha1 || THROW_CCE();
  return true;
};
var OaepWithSha1_instance;
function OaepWithSha1_getInstance() {
  return OaepWithSha1_instance;
}
function OaepWithSha256() {
  this.p5m_1 = 'OaepWithSha256';
  this.q5m_1 = 'RSA-OAEP-256';
}
protoOf(OaepWithSha256).a5m = function () {
  return this.p5m_1;
};
protoOf(OaepWithSha256).o5m = function () {
  return this.q5m_1;
};
protoOf(OaepWithSha256).toString = function () {
  return 'OaepWithSha256';
};
protoOf(OaepWithSha256).hashCode = function () {
  return 1322441651;
};
protoOf(OaepWithSha256).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof OaepWithSha256))
    return false;
  other instanceof OaepWithSha256 || THROW_CCE();
  return true;
};
var OaepWithSha256_instance;
function OaepWithSha256_getInstance() {
  return OaepWithSha256_instance;
}
function Companion_2() {
}
protoOf(Companion_2).b5m = function (identifier) {
  var tmp;
  if (identifier === 'PssWithSha256') {
    tmp = PssWithSha256_instance;
  } else {
    throw IllegalArgumentException_init_$Create$('Unknown rsa signature algorithm ' + identifier);
  }
  return tmp;
};
var Companion_instance_2;
function Companion_getInstance_3() {
  return Companion_instance_2;
}
function PssWithSha256() {
  this.r5m_1 = 'PssWithSha256';
  this.s5m_1 = 'PS256';
}
protoOf(PssWithSha256).a5m = function () {
  return this.r5m_1;
};
protoOf(PssWithSha256).o5m = function () {
  return this.s5m_1;
};
protoOf(PssWithSha256).toString = function () {
  return 'PssWithSha256';
};
protoOf(PssWithSha256).hashCode = function () {
  return 1236907309;
};
protoOf(PssWithSha256).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof PssWithSha256))
    return false;
  other instanceof PssWithSha256 || THROW_CCE();
  return true;
};
var PssWithSha256_instance;
function PssWithSha256_getInstance() {
  return PssWithSha256_instance;
}
function RsaEncryptionAlgorithm() {
}
function RsaSignatureAlgorithm() {
}
function Companion_3() {
}
protoOf(Companion_3).b5m = function (identifier) {
  var tmp;
  switch (identifier) {
    case 'OaepWithSha1':
      tmp = OaepWithSha1_instance;
      break;
    case 'OaepWithSha256':
      tmp = OaepWithSha256_instance;
      break;
    case 'PssWithSha256':
      tmp = PssWithSha256_instance;
      break;
    default:
      throw IllegalArgumentException_init_$Create$('Unknown rsa algorithm ' + identifier);
  }
  return tmp;
};
protoOf(Companion_3).t5m = function (jwkIdentifier) {
  var tmp;
  switch (jwkIdentifier) {
    case 'RSA-OAEP':
      tmp = OaepWithSha1_instance;
      break;
    case 'RSA-OAEP-256':
      tmp = OaepWithSha256_instance;
      break;
    case 'PS256':
      tmp = PssWithSha256_instance;
      break;
    default:
      throw IllegalArgumentException_init_$Create$('Unknown/unsupported rsa jwk algorithm ' + jwkIdentifier);
  }
  return tmp;
};
var Companion_instance_3;
function Companion_getInstance_4() {
  return Companion_instance_3;
}
function RsaKeypair(private_0, public_0) {
  this.u5m_1 = private_0;
  this.v5m_1 = public_0;
  // Inline function 'kotlin.require' call
  // Inline function 'kotlin.contracts.contract' call
  if (!equals(this.u5m_1.x5m_1, this.v5m_1.z5m_1)) {
    // Inline function 'com.icure.kryptom.crypto.RsaKeypair.<anonymous>' call
    var message = 'Private and public keys must have the same algorithm';
    throw IllegalArgumentException_init_$Create$(toString(message));
  }
}
protoOf(RsaKeypair).a5n = function () {
  return this.u5m_1.x5m_1;
};
protoOf(RsaKeypair).toString = function () {
  return 'RsaKeypair(private=' + toString(this.u5m_1) + ', public=' + toString(this.v5m_1) + ')';
};
protoOf(RsaKeypair).hashCode = function () {
  var result = hashCode(this.u5m_1);
  result = imul(result, 31) + hashCode(this.v5m_1) | 0;
  return result;
};
protoOf(RsaKeypair).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof RsaKeypair))
    return false;
  var tmp0_other_with_cast = other instanceof RsaKeypair ? other : THROW_CCE();
  if (!equals(this.u5m_1, tmp0_other_with_cast.u5m_1))
    return false;
  if (!equals(this.v5m_1, tmp0_other_with_cast.v5m_1))
    return false;
  return true;
};
var KeySize_Rsa2048_instance;
var KeySize_Rsa4096_instance;
function values_0() {
  return [KeySize_Rsa2048_getInstance(), KeySize_Rsa4096_getInstance()];
}
function get_entries_0() {
  if ($ENTRIES_0 == null)
    $ENTRIES_0 = enumEntries(values_0());
  return $ENTRIES_0;
}
var KeySize_entriesInitialized_0;
function KeySize_initEntries_0() {
  if (KeySize_entriesInitialized_0)
    return Unit_instance;
  KeySize_entriesInitialized_0 = true;
  KeySize_Rsa2048_instance = new KeySize_0('Rsa2048', 0, 2048);
  KeySize_Rsa4096_instance = new KeySize_0('Rsa4096', 1, 4096);
}
var $ENTRIES_0;
function KeySize_0(name, ordinal, bitSize) {
  Enum.call(this, name, ordinal);
  this.d5n_1 = bitSize;
}
function KeySize_Rsa2048_getInstance() {
  KeySize_initEntries_0();
  return KeySize_Rsa2048_instance;
}
function KeySize_Rsa4096_getInstance() {
  KeySize_initEntries_0();
  return KeySize_Rsa4096_instance;
}
function $exportPrivateKeyJwkCOROUTINE$0(_this__u8e3s4, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.m5n_1 = _this__u8e3s4;
  this.n5n_1 = key;
}
protoOf($exportPrivateKeyJwkCOROUTINE$0).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.o5n_1 = AsnToJwkConverter_instance;
          this.p5n_1 = this.n5n_1.x5m_1;
          this.f9_1 = 1;
          suspendResult = this.m5n_1.q5n(this.n5n_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return this.o5n_1.r5n(this.p5n_1, ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $exportPublicKeyJwkCOROUTINE$1(_this__u8e3s4, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.a5o_1 = _this__u8e3s4;
  this.b5o_1 = key;
}
protoOf($exportPublicKeyJwkCOROUTINE$1).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.c5o_1 = AsnToJwkConverter_instance;
          this.d5o_1 = this.b5o_1.z5m_1;
          this.f9_1 = 1;
          suspendResult = this.a5o_1.e5o(this.b5o_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return this.c5o_1.f5o(this.d5o_1, ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function RsaService() {
}
function StrongRandom() {
}
function Asn1Integer(value) {
  this.x5o_1 = value;
}
protoOf(Asn1Integer).y5o = function () {
  return AsnUtils_instance.a5p(this.x5o_1, this.z5o());
};
protoOf(Asn1Integer).toString = function () {
  return 'Asn1Integer(value=' + toString(this.x5o_1) + ')';
};
protoOf(Asn1Integer).hashCode = function () {
  return hashCode(this.x5o_1);
};
protoOf(Asn1Integer).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof Asn1Integer))
    return false;
  var tmp0_other_with_cast = other instanceof Asn1Integer ? other : THROW_CCE();
  if (!equals(this.x5o_1, tmp0_other_with_cast.x5o_1))
    return false;
  return true;
};
function Asn1OctetString(value) {
  this.b5p_1 = value;
}
protoOf(Asn1OctetString).c5p = function () {
  var tmp;
  try {
    tmp = toAsn1(this.b5p_1);
  } catch ($p) {
    var tmp_0;
    if ($p instanceof Exception) {
      var e = $p;
      tmp_0 = null;
    } else {
      throw $p;
    }
    tmp = tmp_0;
  }
  return tmp;
};
protoOf(Asn1OctetString).y5o = function () {
  return AsnUtils_instance.a5p(this.b5p_1, this.z5o());
};
protoOf(Asn1OctetString).toString = function () {
  return 'Asn1OctetString(value=' + toString(this.b5p_1) + ')';
};
protoOf(Asn1OctetString).hashCode = function () {
  return hashCode(this.b5p_1);
};
protoOf(Asn1OctetString).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof Asn1OctetString))
    return false;
  var tmp0_other_with_cast = other instanceof Asn1OctetString ? other : THROW_CCE();
  if (!equals(this.b5p_1, tmp0_other_with_cast.b5p_1))
    return false;
  return true;
};
function Asn1Sequence(value) {
  this.d5p_1 = value;
}
protoOf(Asn1Sequence).y5o = function () {
  var tmp = AsnUtils_instance;
  // Inline function 'kotlin.collections.fold' call
  var this_0 = this.d5p_1;
  var accumulator = new Int8Array(0);
  var tmp0_iterator = this_0.p();
  while (tmp0_iterator.q()) {
    var element = tmp0_iterator.r();
    // Inline function 'com.icure.kryptom.crypto.asn.Asn1Sequence.pack.<anonymous>' call
    // Inline function 'kotlin.collections.plus' call
    var this_1 = accumulator;
    var elements = element.y5o();
    accumulator = primitiveArrayConcat([this_1, elements]);
  }
  var tmp$ret$2 = accumulator;
  return tmp.a5p(tmp$ret$2, this.z5o());
};
protoOf(Asn1Sequence).toString = function () {
  return 'Asn1Sequence(value=' + toString(this.d5p_1) + ')';
};
protoOf(Asn1Sequence).hashCode = function () {
  return hashCode(this.d5p_1);
};
protoOf(Asn1Sequence).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof Asn1Sequence))
    return false;
  var tmp0_other_with_cast = other instanceof Asn1Sequence ? other : THROW_CCE();
  if (!equals(this.d5p_1, tmp0_other_with_cast.d5p_1))
    return false;
  return true;
};
function Asn1Enumerated(value) {
  this.e5p_1 = value;
}
protoOf(Asn1Enumerated).y5o = function () {
  return AsnUtils_instance.a5p(AsnUtils_instance.f5p(this.e5p_1), this.z5o());
};
protoOf(Asn1Enumerated).toString = function () {
  return 'Asn1Enumerated(value=' + this.e5p_1 + ')';
};
protoOf(Asn1Enumerated).hashCode = function () {
  return this.e5p_1;
};
protoOf(Asn1Enumerated).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof Asn1Enumerated))
    return false;
  var tmp0_other_with_cast = other instanceof Asn1Enumerated ? other : THROW_CCE();
  if (!(this.e5p_1 === tmp0_other_with_cast.e5p_1))
    return false;
  return true;
};
function Asn1Null() {
}
protoOf(Asn1Null).y5o = function () {
  // Inline function 'kotlin.byteArrayOf' call
  return new Int8Array([toByte(this.z5o()), 0]);
};
function Asn1Oid(value) {
  this.g5p_1 = value;
}
protoOf(Asn1Oid).y5o = function () {
  return AsnUtils_instance.a5p(AsnUtils_instance.h5p(this.g5p_1), this.z5o());
};
protoOf(Asn1Oid).toString = function () {
  return 'Asn1Oid(value=' + this.g5p_1 + ')';
};
protoOf(Asn1Oid).hashCode = function () {
  return getStringHashCode(this.g5p_1);
};
protoOf(Asn1Oid).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof Asn1Oid))
    return false;
  var tmp0_other_with_cast = other instanceof Asn1Oid ? other : THROW_CCE();
  if (!(this.g5p_1 === tmp0_other_with_cast.g5p_1))
    return false;
  return true;
};
function Asn1Boolean(value) {
  this.i5p_1 = value;
}
protoOf(Asn1Boolean).y5o = function () {
  // Inline function 'kotlin.byteArrayOf' call
  return new Int8Array([toByte(this.z5o()), 1, this.i5p_1 ? -1 : 0]);
};
protoOf(Asn1Boolean).toString = function () {
  return 'Asn1Boolean(value=' + this.i5p_1 + ')';
};
protoOf(Asn1Boolean).hashCode = function () {
  return getBooleanHashCode(this.i5p_1);
};
protoOf(Asn1Boolean).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof Asn1Boolean))
    return false;
  var tmp0_other_with_cast = other instanceof Asn1Boolean ? other : THROW_CCE();
  if (!(this.i5p_1 === tmp0_other_with_cast.i5p_1))
    return false;
  return true;
};
function Asn1BitString(value) {
  this.j5p_1 = value;
}
protoOf(Asn1BitString).c5p = function () {
  var tmp;
  try {
    // Inline function 'kotlin.takeIf' call
    var this_0 = this.j5p_1;
    // Inline function 'kotlin.contracts.contract' call
    var tmp_0;
    // Inline function 'com.icure.kryptom.crypto.asn.Asn1BitString.<get-nested>.<anonymous>' call
    if (this_0[0] === 0) {
      tmp_0 = this_0;
    } else {
      tmp_0 = null;
    }
    var tmp0_elvis_lhs = tmp_0;
    var tmp_1;
    if (tmp0_elvis_lhs == null) {
      throw IllegalArgumentException_init_$Create$('Bit strings with non zero bit masks are not supported');
    } else {
      tmp_1 = tmp0_elvis_lhs;
    }
    tmp = toAsn1(toByteArray(drop(tmp_1, 1)));
  } catch ($p) {
    var tmp_2;
    if ($p instanceof Exception) {
      var e = $p;
      tmp_2 = null;
    } else {
      throw $p;
    }
    tmp = tmp_2;
  }
  return tmp;
};
protoOf(Asn1BitString).y5o = function () {
  return AsnUtils_instance.a5p(this.j5p_1, this.z5o());
};
protoOf(Asn1BitString).toString = function () {
  return 'Asn1BitString(value=' + toString(this.j5p_1) + ')';
};
protoOf(Asn1BitString).hashCode = function () {
  return hashCode(this.j5p_1);
};
protoOf(Asn1BitString).equals = function (other) {
  if (this === other)
    return true;
  if (!(other instanceof Asn1BitString))
    return false;
  var tmp0_other_with_cast = other instanceof Asn1BitString ? other : THROW_CCE();
  if (!equals(this.j5p_1, tmp0_other_with_cast.j5p_1))
    return false;
  return true;
};
function Asn1Object() {
}
function toAsn1(_this__u8e3s4) {
  var offset = {_v: 0};
  return toAsn1$parse(offset, _this__u8e3s4);
}
function AsnUtils() {
}
protoOf(AsnUtils).k5p = function (_this__u8e3s4) {
  return this.l5p(_this__u8e3s4).l1();
};
protoOf(AsnUtils).l5p = function (_this__u8e3s4) {
  // Inline function 'kotlin.collections.fold' call
  var accumulator = new Long(0, 0);
  var inductionVariable = 0;
  var last = _this__u8e3s4.length;
  while (inductionVariable < last) {
    var element = _this__u8e3s4[inductionVariable];
    inductionVariable = inductionVariable + 1 | 0;
    // Inline function 'com.icure.kryptom.crypto.asn.AsnUtils.toLong.<anonymous>' call
    var tmp = accumulator.k3(8);
    // Inline function 'kotlin.UByte.toLong' call
    // Inline function 'kotlin.toUByte' call
    var this_0 = _UByte___init__impl__g9hnc4(element);
    var tmp$ret$1 = toLong(_UByte___get_data__impl__jof9qr(this_0)).n3(new Long(255, 0));
    accumulator = tmp.o3(tmp$ret$1);
  }
  return accumulator;
};
protoOf(AsnUtils).h5p = function (_this__u8e3s4) {
  // Inline function 'kotlin.collections.map' call
  var this_0 = split(_this__u8e3s4, charArrayOf([_Char___init__impl__6a9atx(46)]));
  // Inline function 'kotlin.collections.mapTo' call
  var destination = ArrayList_init_$Create$(collectionSizeOrDefault(this_0, 10));
  var tmp0_iterator = this_0.p();
  while (tmp0_iterator.q()) {
    var item = tmp0_iterator.r();
    // Inline function 'com.icure.kryptom.crypto.asn.AsnUtils.toOidByteArray.<anonymous>' call
    var tmp$ret$0 = toInt(item);
    destination.k(tmp$ret$0);
  }
  var oidParts = destination;
  var firstByte = toByte(imul(oidParts.u(0), 40) + oidParts.u(1) | 0);
  // Inline function 'kotlin.collections.flatMap' call
  // Inline function 'kotlin.collections.flatMapTo' call
  var this_1 = drop_0(oidParts, 2);
  var destination_0 = ArrayList_init_$Create$_0();
  var tmp0_iterator_0 = this_1.p();
  while (tmp0_iterator_0.q()) {
    var element = tmp0_iterator_0.r();
    // Inline function 'com.icure.kryptom.crypto.asn.AsnUtils.toOidByteArray.<anonymous>' call
    var list = AsnUtils_instance.m5p(element);
    addAll(destination_0, list);
  }
  var otherBytes = destination_0;
  // Inline function 'kotlin.collections.plus' call
  // Inline function 'kotlin.byteArrayOf' call
  var this_2 = new Int8Array([firstByte]);
  var elements = toByteArray(otherBytes);
  return primitiveArrayConcat([this_2, elements]);
};
protoOf(AsnUtils).m5p = function (_this__u8e3s4) {
  var value = _this__u8e3s4;
  // Inline function 'kotlin.collections.mutableListOf' call
  var bytes = ArrayList_init_$Create$_0();
  do {
    var byte = value & 127;
    // Inline function 'kotlin.collections.isNotEmpty' call
    if (!bytes.h())
      byte = byte | 128;
    bytes.k2(0, toByte(byte));
    value = value >> 7;
  }
   while (!(value === 0));
  return bytes;
};
protoOf(AsnUtils).n5p = function (_this__u8e3s4) {
  var tmp;
  if (_this__u8e3s4 < 128) {
    // Inline function 'kotlin.byteArrayOf' call
    tmp = new Int8Array([toByte(_this__u8e3s4)]);
  } else {
    // Inline function 'kotlin.collections.dropWhile' call
    var this_0 = this.f5p(_this__u8e3s4);
    var yielding = false;
    var list = ArrayList_init_$Create$_0();
    var inductionVariable = 0;
    var last = this_0.length;
    while (inductionVariable < last) {
      var item = this_0[inductionVariable];
      inductionVariable = inductionVariable + 1 | 0;
      if (yielding) {
        list.k(item);
      } else {
        // Inline function 'com.icure.kryptom.crypto.asn.AsnUtils.toAsn1Length.<anonymous>' call
        if (!(item === 0)) {
          list.k(item);
          yielding = true;
        }
      }
    }
    var lengthBytes = list;
    // Inline function 'kotlin.byteArrayOf' call
    var tmp$ret$3 = new Int8Array([toByte(128 | lengthBytes.s())]);
    tmp = plus(tmp$ret$3, lengthBytes);
  }
  return tmp;
};
protoOf(AsnUtils).a5p = function (_this__u8e3s4, tag) {
  // Inline function 'kotlin.collections.plus' call
  // Inline function 'kotlin.collections.plus' call
  // Inline function 'kotlin.byteArrayOf' call
  var this_0 = new Int8Array([toByte(tag)]);
  var elements = this.n5p(_this__u8e3s4.length);
  var this_1 = primitiveArrayConcat([this_0, elements]);
  return primitiveArrayConcat([this_1, _this__u8e3s4]);
};
protoOf(AsnUtils).f5p = function (_this__u8e3s4) {
  if (_this__u8e3s4 === 0) {
    // Inline function 'kotlin.byteArrayOf' call
    return new Int8Array([0]);
  }
  var i = _this__u8e3s4;
  var result = new Int8Array(4);
  var inductionVariable = 3;
  if (0 <= inductionVariable)
    do {
      var index = inductionVariable;
      inductionVariable = inductionVariable + -1 | 0;
      result[index] = toByte(i & 255);
      i = i >> 8;
    }
     while (0 <= inductionVariable);
  // Inline function 'kotlin.collections.dropWhile' call
  var yielding = false;
  var list = ArrayList_init_$Create$_0();
  var inductionVariable_0 = 0;
  var last = result.length;
  while (inductionVariable_0 < last) {
    var item = result[inductionVariable_0];
    inductionVariable_0 = inductionVariable_0 + 1 | 0;
    if (yielding) {
      list.k(item);
    } else {
      // Inline function 'com.icure.kryptom.crypto.asn.AsnUtils.toByteArray.<anonymous>' call
      if (!(item === 0)) {
        list.k(item);
        yielding = true;
      }
    }
  }
  return toByteArray(list);
};
var AsnUtils_instance;
function AsnUtils_getInstance() {
  return AsnUtils_instance;
}
function toAsn1$next($this_toAsn1, offset) {
  // Inline function 'kotlin.toUByte' call
  var _unary__edvuaz = offset._v;
  offset._v = _unary__edvuaz + 1 | 0;
  var this_0 = $this_toAsn1[_unary__edvuaz];
  return _UByte___init__impl__g9hnc4(this_0);
}
function toAsn1$readLength($this_toAsn1, offset) {
  // Inline function 'kotlin.UByte.toInt' call
  var this_0 = toAsn1$next($this_toAsn1, offset);
  var length = _UByte___get_data__impl__jof9qr(this_0) & 255;
  if (!((length & 128) === 0)) {
    var numOctets = length & 127;
    length = 0;
    // Inline function 'kotlin.repeat' call
    // Inline function 'kotlin.contracts.contract' call
    var inductionVariable = 0;
    if (inductionVariable < numOctets)
      do {
        var index = inductionVariable;
        inductionVariable = inductionVariable + 1 | 0;
        // Inline function 'com.icure.kryptom.crypto.asn.toAsn1.readLength.<anonymous>' call
        var tmp = length << 8;
        // Inline function 'kotlin.UByte.toInt' call
        var this_1 = toAsn1$next($this_toAsn1, offset);
        length = tmp | _UByte___get_data__impl__jof9qr(this_1) & 255;
      }
       while (inductionVariable < numOctets);
  }
  return length;
}
function toAsn1$readContent($this_toAsn1, offset, length) {
  // Inline function 'kotlin.also' call
  var this_0 = copyOfRange($this_toAsn1, offset._v, offset._v + length | 0);
  // Inline function 'kotlin.contracts.contract' call
  // Inline function 'com.icure.kryptom.crypto.asn.toAsn1.readContent.<anonymous>' call
  offset._v = offset._v + length | 0;
  return this_0;
}
function toAsn1$parseOid($this_toAsn1, offset, length) {
  var oidBytes = toAsn1$readContent($this_toAsn1, offset, length);
  var firstByte = oidBytes[0];
  var oid = mutableListOf([firstByte / 40 | 0, firstByte % 40 | 0]);
  var value = 0;
  var _iterator__ex2g4s = drop(oidBytes, 1).p();
  while (_iterator__ex2g4s.q()) {
    var b = _iterator__ex2g4s.r();
    value = value << 7 | b & 127;
    if ((b & 128) === 0) {
      oid.k(value);
      value = 0;
    }
  }
  return joinToString(oid, '.');
}
function toAsn1$parse(offset, $this_toAsn1) {
  // Inline function 'kotlin.UByte.toInt' call
  var this_0 = toAsn1$next($this_toAsn1, offset);
  var tag = _UByte___get_data__impl__jof9qr(this_0) & 255;
  var length = toAsn1$readLength($this_toAsn1, offset);
  var tmp;
  switch (tag) {
    case 1:
      tmp = new Asn1Boolean(!(first(toAsn1$readContent($this_toAsn1, offset, 1)) === 0));
      break;
    case 2:
      tmp = new Asn1Integer(toAsn1$readContent($this_toAsn1, offset, length));
      break;
    case 3:
      tmp = new Asn1BitString(toAsn1$readContent($this_toAsn1, offset, length));
      break;
    case 4:
      tmp = new Asn1OctetString(toAsn1$readContent($this_toAsn1, offset, length));
      break;
    case 5:
      tmp = new Asn1Null();
      break;
    case 10:
      tmp = new Asn1Enumerated(AsnUtils_instance.k5p(toAsn1$readContent($this_toAsn1, offset, length)));
      break;
    case 6:
      tmp = new Asn1Oid(toAsn1$parseOid($this_toAsn1, offset, length));
      break;
    case 48:
      var end = offset._v + length | 0;
      // Inline function 'kotlin.collections.mutableListOf' call

      var sequence = ArrayList_init_$Create$_0();
      while (offset._v < end) {
        sequence.k(toAsn1$parse(offset, $this_toAsn1));
      }

      tmp = new Asn1Sequence(sequence);
      break;
    default:
      throw IllegalArgumentException_init_$Create$('Unsupported tag: ' + tag);
  }
  return tmp;
}
function encodeForJwk(_this__u8e3s4, $this) {
  var tmp$ret$3;
  $l$block: {
    // Inline function 'kotlin.text.dropLastWhile' call
    var tmp;
    if (_this__u8e3s4.x5o_1[0] === 0) {
      tmp = sliceArray(_this__u8e3s4.x5o_1, until(1, _this__u8e3s4.x5o_1.length));
    } else {
      tmp = _this__u8e3s4.x5o_1;
    }
    var this_0 = base64UrlEncode(tmp);
    var inductionVariable = get_lastIndex(this_0);
    if (0 <= inductionVariable)
      do {
        var index = inductionVariable;
        inductionVariable = inductionVariable + -1 | 0;
        // Inline function 'com.icure.kryptom.crypto.asn.AsnToJwkConverter.encodeForJwk.<anonymous>' call
        if (!(charSequenceGet(this_0, index) === _Char___init__impl__6a9atx(61))) {
          // Inline function 'kotlin.text.substring' call
          var endIndex = index + 1 | 0;
          // Inline function 'kotlin.js.asDynamic' call
          tmp$ret$3 = this_0.substring(0, endIndex);
          break $l$block;
        }
      }
       while (0 <= inductionVariable);
    tmp$ret$3 = '';
  }
  return tmp$ret$3;
}
function decodeToAsn1Integer(_this__u8e3s4, $this) {
  var data = base64UrlDecode(_this__u8e3s4);
  var paddingNeeded = data[0] < 0;
  var tmp;
  if (paddingNeeded) {
    // Inline function 'kotlin.collections.plus' call
    // Inline function 'kotlin.byteArrayOf' call
    var this_0 = new Int8Array([0]);
    tmp = primitiveArrayConcat([this_0, data]);
  } else {
    tmp = data;
  }
  var paddedData = tmp;
  return new Asn1Integer(paddedData);
}
function AsnToJwkConverter() {
}
protoOf(AsnToJwkConverter).f5o = function (algorithm, spki) {
  var asn1 = toAsn1(spki);
  var tmp;
  var tmp_0;
  if (asn1 instanceof Asn1Sequence) {
    var tmp_1 = asn1.d5p_1.u(0);
    var tmp1_safe_receiver = tmp_1 instanceof Asn1Sequence ? tmp_1 : null;
    var tmp_2;
    if (tmp1_safe_receiver == null) {
      tmp_2 = null;
    } else {
      // Inline function 'kotlin.let' call
      // Inline function 'kotlin.contracts.contract' call
      // Inline function 'com.icure.kryptom.crypto.asn.AsnToJwkConverter.spkiToJwk.<anonymous>' call
      var tmp_3 = tmp1_safe_receiver.d5p_1.u(0);
      var tmp0_safe_receiver = tmp_3 instanceof Asn1Oid ? tmp_3 : null;
      var tmp_4;
      if (tmp0_safe_receiver == null) {
        tmp_4 = null;
      } else {
        // Inline function 'kotlin.let' call
        // Inline function 'kotlin.contracts.contract' call
        // Inline function 'com.icure.kryptom.crypto.asn.AsnToJwkConverter.spkiToJwk.<anonymous>.<anonymous>' call
        tmp_4 = tmp0_safe_receiver.g5p_1 === '1.2.840.113549.1.1.1';
      }
      tmp_2 = tmp_4;
    }
    tmp_0 = tmp_2 === true;
  } else {
    tmp_0 = false;
  }
  if (tmp_0) {
    var tmp_5 = asn1.d5p_1.u(1);
    var tmp_6 = (tmp_5 instanceof Asn1BitString ? tmp_5 : THROW_CCE()).c5p();
    var tmp0_elvis_lhs = tmp_6 instanceof Asn1Sequence ? tmp_6 : null;
    var tmp_7;
    if (tmp0_elvis_lhs == null) {
      throw IllegalArgumentException_init_$Create$('Invalid spki format - expected a nested sequence');
    } else {
      tmp_7 = tmp0_elvis_lhs;
    }
    var nested = tmp_7;
    var tmp_8 = nested.d5p_1.u(0);
    var tmp_9 = tmp_8 instanceof Asn1Integer ? tmp_8 : THROW_CCE();
    var tmp_10 = nested.d5p_1.u(1);
    tmp = new Pair(tmp_9, tmp_10 instanceof Asn1Integer ? tmp_10 : THROW_CCE());
  } else {
    var tmp_11;
    var tmp_12;
    if (asn1 instanceof Asn1Sequence) {
      var tmp_13 = asn1.d5p_1.u(0);
      tmp_12 = tmp_13 instanceof Asn1Integer;
    } else {
      tmp_12 = false;
    }
    if (tmp_12) {
      var tmp_14 = asn1.d5p_1.u(1);
      tmp_11 = tmp_14 instanceof Asn1Integer;
    } else {
      tmp_11 = false;
    }
    if (tmp_11) {
      var tmp_15 = asn1.d5p_1.u(0);
      var tmp_16 = tmp_15 instanceof Asn1Integer ? tmp_15 : THROW_CCE();
      var tmp_17 = asn1.d5p_1.u(1);
      tmp = new Pair(tmp_16, tmp_17 instanceof Asn1Integer ? tmp_17 : THROW_CCE());
    } else {
      throw IllegalArgumentException_init_$Create$('Invalid spki format');
    }
  }
  var _destruct__k2r9zo = tmp;
  var modulus = _destruct__k2r9zo.xa();
  var exponent = _destruct__k2r9zo.ya();
  var tmp2_alg = algorithm.o5m();
  var tmp_18;
  if (isInterface(algorithm, RsaSignatureAlgorithm)) {
    tmp_18 = setOf('verify');
  } else {
    tmp_18 = setOf('encrypt');
  }
  var tmp3_key_ops = tmp_18;
  var tmp4_n = encodeForJwk(modulus, this);
  var tmp5_e = encodeForJwk(exponent, this);
  return new PublicRsaKeyJwk(tmp2_alg, tmp5_e, true, tmp3_key_ops, tmp4_n);
};
protoOf(AsnToJwkConverter).p5o = function (jwk) {
  var tmp = new Asn1Sequence(listOf([new Asn1Oid('1.2.840.113549.1.1.1'), new Asn1Null()]));
  // Inline function 'kotlin.collections.plus' call
  // Inline function 'kotlin.byteArrayOf' call
  var this_0 = new Int8Array([0]);
  var elements = (new Asn1Sequence(listOf([decodeToAsn1Integer(jwk.x5l_1, this), decodeToAsn1Integer(jwk.u5l_1, this)]))).y5o();
  var tmp$ret$1 = primitiveArrayConcat([this_0, elements]);
  return (new Asn1Sequence(listOf([tmp, new Asn1BitString(tmp$ret$1)]))).y5o();
};
protoOf(AsnToJwkConverter).r5n = function (algorithm, pkcs8) {
  var asn1 = toAsn1(pkcs8);
  // Inline function 'kotlin.let' call
  var tmp0_elvis_lhs = asn1 instanceof Asn1Sequence ? asn1 : null;
  var tmp;
  if (tmp0_elvis_lhs == null) {
    throw IllegalArgumentException_init_$Create$('Invalid pkcs8 format - expected a sequence');
  } else {
    tmp = tmp0_elvis_lhs;
  }
  // Inline function 'kotlin.contracts.contract' call
  // Inline function 'com.icure.kryptom.crypto.asn.AsnToJwkConverter.pkcs8ToJwk.<anonymous>' call
  var seq = tmp;
  var tmp_0;
  var tmp_1;
  if (seq.d5p_1.s() === 3) {
    var tmp_2 = seq.d5p_1.u(2);
    var tmp1_safe_receiver = tmp_2 instanceof Asn1OctetString ? tmp_2 : null;
    var tmp_3;
    if (tmp1_safe_receiver == null) {
      tmp_3 = null;
    } else {
      // Inline function 'kotlin.let' call
      // Inline function 'kotlin.contracts.contract' call
      // Inline function 'com.icure.kryptom.crypto.asn.AsnToJwkConverter.pkcs8ToJwk.<anonymous>.<anonymous>' call
      var tmp_4 = tmp1_safe_receiver.c5p();
      var tmp0_safe_receiver = tmp_4 instanceof Asn1Sequence ? tmp_4 : null;
      var tmp1_safe_receiver_0 = tmp0_safe_receiver == null ? null : tmp0_safe_receiver.d5p_1;
      tmp_3 = (tmp1_safe_receiver_0 == null ? null : tmp1_safe_receiver_0.s()) === 9;
    }
    tmp_1 = tmp_3 === true;
  } else {
    tmp_1 = false;
  }
  if (tmp_1) {
    var tmp_5 = seq.d5p_1.u(2);
    var tmp0_safe_receiver_0 = tmp_5 instanceof Asn1OctetString ? tmp_5 : null;
    var tmp_6 = tmp0_safe_receiver_0 == null ? null : tmp0_safe_receiver_0.c5p();
    tmp_0 = tmp_6 instanceof Asn1Sequence ? tmp_6 : THROW_CCE();
  } else {
    tmp_0 = seq;
  }
  var seq_0 = tmp_0;
  var tmp_7 = seq_0.d5p_1.u(1);
  var tmp1_n = encodeForJwk(tmp_7 instanceof Asn1Integer ? tmp_7 : THROW_CCE(), this);
  var tmp_8 = seq_0.d5p_1.u(2);
  var tmp2_e = encodeForJwk(tmp_8 instanceof Asn1Integer ? tmp_8 : THROW_CCE(), this);
  var tmp_9 = seq_0.d5p_1.u(3);
  var tmp3_d = encodeForJwk(tmp_9 instanceof Asn1Integer ? tmp_9 : THROW_CCE(), this);
  var tmp_10 = seq_0.d5p_1.u(4);
  var tmp4_p = encodeForJwk(tmp_10 instanceof Asn1Integer ? tmp_10 : THROW_CCE(), this);
  var tmp_11 = seq_0.d5p_1.u(5);
  var tmp5_q = encodeForJwk(tmp_11 instanceof Asn1Integer ? tmp_11 : THROW_CCE(), this);
  var tmp_12 = seq_0.d5p_1.u(6);
  var tmp6_dp = encodeForJwk(tmp_12 instanceof Asn1Integer ? tmp_12 : THROW_CCE(), this);
  var tmp_13 = seq_0.d5p_1.u(7);
  var tmp7_dq = encodeForJwk(tmp_13 instanceof Asn1Integer ? tmp_13 : THROW_CCE(), this);
  var tmp_14 = seq_0.d5p_1.u(8);
  var tmp8_qi = encodeForJwk(tmp_14 instanceof Asn1Integer ? tmp_14 : THROW_CCE(), this);
  var tmp9_alg = algorithm.o5m();
  var tmp_15;
  if (isInterface(algorithm, RsaSignatureAlgorithm)) {
    tmp_15 = setOf('sign');
  } else {
    tmp_15 = setOf('decrypt');
  }
  var tmp10_key_ops = tmp_15;
  return new PrivateRsaKeyJwk(tmp9_alg, tmp3_d, tmp6_dp, tmp7_dq, tmp2_e, true, tmp10_key_ops, tmp1_n, tmp4_p, tmp5_q, tmp8_qi);
};
protoOf(AsnToJwkConverter).m5o = function (jwk) {
  // Inline function 'kotlin.byteArrayOf' call
  var tmp$ret$0 = new Int8Array([0]);
  var tmp = new Asn1Integer(tmp$ret$0);
  var tmp_0 = new Asn1Sequence(listOf([new Asn1Oid('1.2.840.113549.1.1.1'), new Asn1Null()]));
  // Inline function 'kotlin.byteArrayOf' call
  var tmp$ret$1 = new Int8Array([0]);
  return (new Asn1Sequence(listOf([tmp, tmp_0, new Asn1OctetString((new Asn1Sequence(listOf([new Asn1Integer(tmp$ret$1), decodeToAsn1Integer(jwk.o5l_1, this), decodeToAsn1Integer(jwk.l5l_1, this), decodeToAsn1Integer(jwk.i5l_1, this), decodeToAsn1Integer(jwk.p5l_1, this), decodeToAsn1Integer(jwk.q5l_1, this), decodeToAsn1Integer(jwk.j5l_1, this), decodeToAsn1Integer(jwk.k5l_1, this), decodeToAsn1Integer(jwk.r5l_1, this)]))).y5o())]))).y5o();
};
var AsnToJwkConverter_instance;
function AsnToJwkConverter_getInstance() {
  return AsnToJwkConverter_instance;
}
function get_BASE32_INVERSE_ALPHABET_STANDARD() {
  _init_properties_Base32_kt__x6ecls();
  return BASE32_INVERSE_ALPHABET_STANDARD;
}
var BASE32_INVERSE_ALPHABET_STANDARD;
function base32Decode(base32String) {
  _init_properties_Base32_kt__x6ecls();
  return decodeBase32(base32String, get_BASE32_INVERSE_ALPHABET_STANDARD());
}
function base32Encode(bytes) {
  _init_properties_Base32_kt__x6ecls();
  return encodeBase32(bytes, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567');
}
function decodeBase32(input, lookupTable) {
  _init_properties_Base32_kt__x6ecls();
  // Inline function 'kotlin.text.isEmpty' call
  if (charSequenceLength(input) === 0) {
    // Inline function 'kotlin.byteArrayOf' call
    return new Int8Array([]);
  }
  var tmp;
  if (last(input) === _Char___init__impl__6a9atx(61)) {
    // Inline function 'kotlin.require' call
    // Inline function 'kotlin.contracts.contract' call
    if (!((input.length % 8 | 0) === 0)) {
      // Inline function 'com.icure.kryptom.utils.decodeBase32.<anonymous>' call
      var message = 'Invalid padded base32 string length: ' + input.length;
      throw IllegalArgumentException_init_$Create$(toString(message));
    }
    // Inline function 'kotlin.require' call
    // Inline function 'kotlin.contracts.contract' call
    if (!!(charSequenceGet(input, input.length - 7 | 0) === _Char___init__impl__6a9atx(61))) {
      // Inline function 'com.icure.kryptom.utils.decodeBase32.<anonymous>' call
      var message_0 = 'Too much padding';
      throw IllegalArgumentException_init_$Create$(toString(message_0));
    }
    var tmp$ret$5;
    $l$block: {
      // Inline function 'kotlin.text.indexOfFirst' call
      var inductionVariable = 0;
      var last_0 = charSequenceLength(input) - 1 | 0;
      if (inductionVariable <= last_0)
        do {
          var index = inductionVariable;
          inductionVariable = inductionVariable + 1 | 0;
          // Inline function 'com.icure.kryptom.utils.decodeBase32.<anonymous>' call
          if (charSequenceGet(input, index) === _Char___init__impl__6a9atx(61)) {
            tmp$ret$5 = index;
            break $l$block;
          }
        }
         while (inductionVariable <= last_0);
      tmp$ret$5 = -1;
    }
    var lastPadIndex = tmp$ret$5;
    // Inline function 'kotlin.require' call
    // Inline function 'kotlin.contracts.contract' call
    if (!(lastPadIndex > (input.length - 7 | 0))) {
      // Inline function 'com.icure.kryptom.utils.decodeBase32.<anonymous>' call
      var message_1 = 'Invalid base32 string, padding before last octets';
      throw IllegalArgumentException_init_$Create$(toString(message_1));
    }
    // Inline function 'kotlin.text.substring' call
    // Inline function 'kotlin.js.asDynamic' call
    tmp = input.substring(0, lastPadIndex);
  } else {
    tmp = input;
  }
  var unpaddedData = tmp;
  // Inline function 'kotlin.apply' call
  var this_0 = new Buffer();
  // Inline function 'kotlin.contracts.contract' call
  // Inline function 'com.icure.kryptom.utils.decodeBase32.<anonymous>' call
  writeString(this_0, unpaddedData);
  var packet = this_0;
  var bufferSize = 8;
  var data = new Int8Array(bufferSize);
  // Inline function 'kotlin.apply' call
  var this_1 = new Buffer();
  // Inline function 'kotlin.contracts.contract' call
  // Inline function 'com.icure.kryptom.utils.decodeBase32.<anonymous>' call
  while (!packet.p1h()) {
    var read = packet.o1i(data);
    // Inline function 'kotlin.collections.foldIndexed' call
    // Inline function 'kotlin.let' call
    // Inline function 'kotlin.contracts.contract' call
    // Inline function 'com.icure.kryptom.utils.decodeBase32.<anonymous>.<anonymous>' call
    var tmp_0;
    if (read < bufferSize) {
      tmp_0 = sliceArray(data, until(0, read));
    } else {
      tmp_0 = data;
    }
    var this_2 = tmp_0;
    var index_0 = 0;
    var accumulator = new Long(0, 0);
    var inductionVariable_0 = 0;
    var last_1 = this_2.length;
    while (inductionVariable_0 < last_1) {
      var element = this_2[inductionVariable_0];
      inductionVariable_0 = inductionVariable_0 + 1 | 0;
      // Inline function 'com.icure.kryptom.utils.decodeBase32.<anonymous>.<anonymous>' call
      var tmp1 = index_0;
      index_0 = tmp1 + 1 | 0;
      var result = accumulator;
      var tmp0_safe_receiver = getOrNull(lookupTable, element);
      var tmp_1;
      if (tmp0_safe_receiver == null) {
        tmp_1 = null;
      } else {
        // Inline function 'kotlin.takeIf' call
        // Inline function 'kotlin.contracts.contract' call
        var tmp_2;
        // Inline function 'com.icure.kryptom.utils.decodeBase32.<anonymous>.<anonymous>.<anonymous>' call
        if (tmp0_safe_receiver.g1(new Long(0, 0)) >= 0) {
          tmp_2 = tmp0_safe_receiver;
        } else {
          tmp_2 = null;
        }
        tmp_1 = tmp_2;
      }
      var tmp1_elvis_lhs = tmp_1;
      var tmp_3;
      if (tmp1_elvis_lhs == null) {
        throw IllegalArgumentException_init_$Create$('Invalid base32 character: ' + element);
      } else {
        tmp_3 = tmp1_elvis_lhs;
      }
      var found = tmp_3;
      accumulator = result.o3(found.k3(imul(7 - tmp1 | 0, 5)));
    }
    var chunk = accumulator;
    var tmp_4;
    switch (read) {
      case 2:
        tmp_4 = 4;
        break;
      case 4:
        tmp_4 = 3;
        break;
      case 5:
        tmp_4 = 2;
        break;
      case 7:
        tmp_4 = 1;
        break;
      case 8:
        tmp_4 = 0;
        break;
      default:
        throw IllegalArgumentException_init_$Create$('Invalid base 32 character, loaded ' + read + ' bytes');
    }
    var bytesToLoad = tmp_4;
    var inductionVariable_1 = 4;
    if (bytesToLoad <= inductionVariable_1)
      do {
        var index_1 = inductionVariable_1;
        inductionVariable_1 = inductionVariable_1 + -1 | 0;
        var origin = chunk.l3(imul(8, index_1)).n3(new Long(255, 0));
        this_1.h1j(origin.q3());
      }
       while (!(index_1 === bytesToLoad));
  }
  return readByteArray(this_1);
}
function encodeBase32(data, alphabet) {
  _init_properties_Base32_kt__x6ecls();
  var position = {_v: 0};
  var writeOffset = 0;
  var charArray_0 = charArray((imul(data.length, 8) / 5 | 0) + 7 | 0);
  while ((position._v + 5 | 0) < data.length) {
    var tmp = 0;
    // Inline function 'kotlin.arrayOfNulls' call
    var tmp_0 = fillArrayVal(Array(5), null);
    while (tmp < 5) {
      var tmp_1 = tmp;
      tmp_0[tmp_1] = toLong(data[position._v + tmp_1 | 0]);
      tmp = tmp + 1 | 0;
    }
    var octets = tmp_0;
    position._v = position._v + 5 | 0;
    // Inline function 'kotlin.collections.foldIndexed' call
    var index = 0;
    var accumulator = new Long(0, 0);
    var inductionVariable = 0;
    var last = octets.length;
    while (inductionVariable < last) {
      var element = octets[inductionVariable];
      inductionVariable = inductionVariable + 1 | 0;
      // Inline function 'com.icure.kryptom.utils.encodeBase32.<anonymous>' call
      var tmp1 = index;
      index = tmp1 + 1 | 0;
      accumulator = accumulator.o3(element.n3(new Long(255, 0)).k3(32 - imul(8, tmp1) | 0));
    }
    var chunk = accumulator;
    var inductionVariable_0 = 7;
    if (0 <= inductionVariable_0)
      do {
        var index_0 = inductionVariable_0;
        inductionVariable_0 = inductionVariable_0 + -1 | 0;
        var char = chunk.l3(imul(5, index_0)).l1() & 31;
        var _unary__edvuaz = writeOffset;
        writeOffset = _unary__edvuaz + 1 | 0;
        charArray_0[_unary__edvuaz] = charSequenceGet(alphabet, char);
      }
       while (0 <= inductionVariable_0);
  }
  var remaining = data.length - position._v | 0;
  if (remaining === 0)
    return concatToString(charArray_0, 0, writeOffset);
  // Inline function 'kotlin.collections.fold' call
  var this_0 = until(0, 5);
  var accumulator_0 = new Long(0, 0);
  var inductionVariable_1 = this_0.h1_1;
  var last_0 = this_0.i1_1;
  if (inductionVariable_1 <= last_0)
    do {
      var element_0 = inductionVariable_1;
      inductionVariable_1 = inductionVariable_1 + 1 | 0;
      // Inline function 'com.icure.kryptom.utils.encodeBase32.<anonymous>' call
      var acc = accumulator_0;
      var idx = element_0;
      var tmp_2;
      if (idx < remaining) {
        tmp_2 = toLong(data[position._v + idx | 0]);
      } else {
        tmp_2 = new Long(0, 0);
      }
      var octet = tmp_2;
      accumulator_0 = acc.o3(octet.n3(new Long(255, 0)).k3(32 - imul(8, idx) | 0));
    }
     while (!(element_0 === last_0));
  var chunk_0 = accumulator_0;
  var padSize = imul(5 - remaining | 0, 8) / 5 | 0;
  var inductionVariable_2 = 7;
  if (padSize <= inductionVariable_2)
    do {
      var index_1 = inductionVariable_2;
      inductionVariable_2 = inductionVariable_2 + -1 | 0;
      var char_0 = chunk_0.l3(imul(5, index_1)).l1() & 31;
      var _unary__edvuaz_0 = writeOffset;
      writeOffset = _unary__edvuaz_0 + 1 | 0;
      charArray_0[_unary__edvuaz_0] = charSequenceGet(alphabet, char_0);
    }
     while (!(index_1 === padSize));
  // Inline function 'kotlin.repeat' call
  // Inline function 'kotlin.contracts.contract' call
  var inductionVariable_3 = 0;
  if (inductionVariable_3 < padSize)
    do {
      var index_2 = inductionVariable_3;
      inductionVariable_3 = inductionVariable_3 + 1 | 0;
      // Inline function 'com.icure.kryptom.utils.encodeBase32.<anonymous>' call
      var _unary__edvuaz_1 = writeOffset;
      writeOffset = _unary__edvuaz_1 + 1 | 0;
      charArray_0[_unary__edvuaz_1] = _Char___init__impl__6a9atx(61);
    }
     while (inductionVariable_3 < padSize);
  return concatToString(charArray_0, 0, writeOffset);
}
var properties_initialized_Base32_kt_5ejedq;
function _init_properties_Base32_kt__x6ecls() {
  if (!properties_initialized_Base32_kt_5ejedq) {
    properties_initialized_Base32_kt_5ejedq = true;
    var tmp = 0;
    var tmp_0 = longArray(256);
    while (tmp < 256) {
      var tmp_1 = tmp;
      tmp_0[tmp_1] = toLong(indexOf('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567', numberToChar(tmp_1)));
      tmp = tmp + 1 | 0;
    }
    BASE32_INVERSE_ALPHABET_STANDARD = tmp_0;
  }
}
function get_BASE64_INVERSE_ALPHABET_STANDARD() {
  _init_properties_Base64_kt__ymmsz3();
  return BASE64_INVERSE_ALPHABET_STANDARD;
}
var BASE64_INVERSE_ALPHABET_STANDARD;
function get_BASE64_INVERSE_ALPHABET_URL() {
  _init_properties_Base64_kt__ymmsz3();
  return BASE64_INVERSE_ALPHABET_URL;
}
var BASE64_INVERSE_ALPHABET_URL;
function base64UrlEncode(bytes) {
  _init_properties_Base64_kt__ymmsz3();
  return encodeBase64(bytes, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_');
}
function base64UrlDecode(base64String) {
  _init_properties_Base64_kt__ymmsz3();
  return decodeBase64(base64String, get_BASE64_INVERSE_ALPHABET_URL());
}
function encodeBase64(data, alphabet) {
  _init_properties_Base64_kt__ymmsz3();
  var position = 0;
  var writeOffset = 0;
  var charArray_0 = charArray((imul(data.length, 8) / 6 | 0) + 3 | 0);
  while ((position + 3 | 0) <= data.length) {
    var first = data[position];
    var second = data[position + 1 | 0];
    var third = data[position + 2 | 0];
    position = position + 3 | 0;
    var chunk = (first & 255) << 16 | (second & 255) << 8 | third & 255;
    var inductionVariable = 3;
    if (0 <= inductionVariable)
      do {
        var index = inductionVariable;
        inductionVariable = inductionVariable + -1 | 0;
        var char = chunk >> imul(6, index) & 63;
        var _unary__edvuaz = writeOffset;
        writeOffset = _unary__edvuaz + 1 | 0;
        charArray_0[_unary__edvuaz] = charSequenceGet(alphabet, char);
      }
       while (0 <= inductionVariable);
  }
  var remaining = data.length - position | 0;
  if (remaining === 0)
    return concatToString(charArray_0, 0, writeOffset);
  var tmp;
  if (remaining === 1) {
    tmp = (data[position] & 255) << 16 | 0 | 0;
  } else {
    tmp = (data[position] & 255) << 16 | (data[position + 1 | 0] & 255) << 8 | 0;
  }
  var chunk_0 = tmp;
  var padSize = imul(3 - remaining | 0, 8) / 6 | 0;
  var inductionVariable_0 = 3;
  if (padSize <= inductionVariable_0)
    do {
      var index_0 = inductionVariable_0;
      inductionVariable_0 = inductionVariable_0 + -1 | 0;
      var char_0 = chunk_0 >> imul(6, index_0) & 63;
      var _unary__edvuaz_0 = writeOffset;
      writeOffset = _unary__edvuaz_0 + 1 | 0;
      charArray_0[_unary__edvuaz_0] = charSequenceGet(alphabet, char_0);
    }
     while (!(index_0 === padSize));
  // Inline function 'kotlin.repeat' call
  // Inline function 'kotlin.contracts.contract' call
  var inductionVariable_1 = 0;
  if (inductionVariable_1 < padSize)
    do {
      var index_1 = inductionVariable_1;
      inductionVariable_1 = inductionVariable_1 + 1 | 0;
      // Inline function 'com.icure.kryptom.utils.encodeBase64.<anonymous>' call
      var _unary__edvuaz_1 = writeOffset;
      writeOffset = _unary__edvuaz_1 + 1 | 0;
      charArray_0[_unary__edvuaz_1] = _Char___init__impl__6a9atx(61);
    }
     while (inductionVariable_1 < padSize);
  return concatToString(charArray_0, 0, writeOffset);
}
function decodeBase64(input, lookupTable) {
  _init_properties_Base64_kt__ymmsz3();
  // Inline function 'kotlin.text.isEmpty' call
  if (charSequenceLength(input) === 0) {
    // Inline function 'kotlin.byteArrayOf' call
    return new Int8Array([]);
  }
  var tmp;
  if (charSequenceGet(input, input.length - 1 | 0) === _Char___init__impl__6a9atx(61)) {
    // Inline function 'kotlin.require' call
    // Inline function 'kotlin.contracts.contract' call
    if (!((input.length % 4 | 0) === 0)) {
      // Inline function 'com.icure.kryptom.utils.decodeBase64.<anonymous>' call
      var message = 'Invalid padded base64 string length: ' + input.length;
      throw IllegalArgumentException_init_$Create$(toString(message));
    }
    // Inline function 'kotlin.require' call
    // Inline function 'kotlin.contracts.contract' call
    if (!!(charSequenceGet(input, input.length - 3 | 0) === _Char___init__impl__6a9atx(61))) {
      // Inline function 'com.icure.kryptom.utils.decodeBase64.<anonymous>' call
      var message_0 = 'Too much padding';
      throw IllegalArgumentException_init_$Create$(toString(message_0));
    }
    var tmp_0;
    if (charSequenceGet(input, input.length - 2 | 0) === _Char___init__impl__6a9atx(61)) {
      // Inline function 'kotlin.text.substring' call
      var endIndex = input.length - 2 | 0;
      // Inline function 'kotlin.js.asDynamic' call
      tmp_0 = input.substring(0, endIndex);
    } else {
      // Inline function 'kotlin.text.substring' call
      var endIndex_0 = input.length - 1 | 0;
      // Inline function 'kotlin.js.asDynamic' call
      tmp_0 = input.substring(0, endIndex_0);
    }
    tmp = tmp_0;
  } else {
    tmp = input;
  }
  var unpaddedData = tmp;
  // Inline function 'kotlin.apply' call
  var this_0 = new Buffer();
  // Inline function 'kotlin.contracts.contract' call
  // Inline function 'com.icure.kryptom.utils.decodeBase64.<anonymous>' call
  writeString(this_0, unpaddedData);
  var packet = this_0;
  var bufferSize = 4;
  var data = new Int8Array(bufferSize);
  // Inline function 'kotlin.apply' call
  var this_1 = new Buffer();
  // Inline function 'kotlin.contracts.contract' call
  // Inline function 'com.icure.kryptom.utils.decodeBase64.<anonymous>' call
  while (!packet.p1h()) {
    var read = packet.o1i(data);
    // Inline function 'kotlin.collections.foldIndexed' call
    // Inline function 'kotlin.let' call
    // Inline function 'kotlin.contracts.contract' call
    // Inline function 'com.icure.kryptom.utils.decodeBase64.<anonymous>.<anonymous>' call
    var tmp_1;
    if (read < bufferSize) {
      tmp_1 = sliceArray(data, until(0, read));
    } else {
      tmp_1 = data;
    }
    var index = 0;
    var accumulator = 0;
    var indexedObject = tmp_1;
    var inductionVariable = 0;
    var last = indexedObject.length;
    while (inductionVariable < last) {
      var element = indexedObject[inductionVariable];
      inductionVariable = inductionVariable + 1 | 0;
      // Inline function 'com.icure.kryptom.utils.decodeBase64.<anonymous>.<anonymous>' call
      var tmp1 = index;
      index = tmp1 + 1 | 0;
      var result = accumulator;
      var tmp0_safe_receiver = getOrNull_0(lookupTable, element);
      var tmp_2;
      if (tmp0_safe_receiver == null) {
        tmp_2 = null;
      } else {
        // Inline function 'kotlin.takeIf' call
        // Inline function 'kotlin.contracts.contract' call
        var tmp_3;
        // Inline function 'com.icure.kryptom.utils.decodeBase64.<anonymous>.<anonymous>.<anonymous>' call
        if (tmp0_safe_receiver >= 0) {
          tmp_3 = tmp0_safe_receiver;
        } else {
          tmp_3 = null;
        }
        tmp_2 = tmp_3;
      }
      var tmp1_elvis_lhs = tmp_2;
      var tmp_4;
      if (tmp1_elvis_lhs == null) {
        throw IllegalArgumentException_init_$Create$('Invalid base64 character: ' + element);
      } else {
        tmp_4 = tmp1_elvis_lhs;
      }
      var found = tmp_4;
      accumulator = result | found << imul(3 - tmp1 | 0, 6);
    }
    var chunk = accumulator;
    var inductionVariable_0 = bufferSize - 2 | 0;
    var last_0 = bufferSize - read | 0;
    if (last_0 <= inductionVariable_0)
      do {
        var index_0 = inductionVariable_0;
        inductionVariable_0 = inductionVariable_0 + -1 | 0;
        var origin = chunk >> imul(8, index_0) & 255;
        this_1.h1j(toByte(origin));
      }
       while (!(index_0 === last_0));
  }
  return readByteArray(this_1);
}
function base64Decode(base64String) {
  _init_properties_Base64_kt__ymmsz3();
  return decodeBase64(base64String, get_BASE64_INVERSE_ALPHABET_STANDARD());
}
function base64Encode(bytes) {
  _init_properties_Base64_kt__ymmsz3();
  return encodeBase64(bytes, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/');
}
var properties_initialized_Base64_kt_5g824v;
function _init_properties_Base64_kt__ymmsz3() {
  if (!properties_initialized_Base64_kt_5g824v) {
    properties_initialized_Base64_kt_5g824v = true;
    var tmp = 0;
    var tmp_0 = new Int32Array(256);
    while (tmp < 256) {
      var tmp_1 = tmp;
      tmp_0[tmp_1] = indexOf('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', numberToChar(tmp_1));
      tmp = tmp + 1 | 0;
    }
    BASE64_INVERSE_ALPHABET_STANDARD = tmp_0;
    var tmp_2 = 0;
    var tmp_3 = new Int32Array(256);
    while (tmp_2 < 256) {
      var tmp_4 = tmp_2;
      tmp_3[tmp_4] = indexOf('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_', numberToChar(tmp_4));
      tmp_2 = tmp_2 + 1 | 0;
    }
    BASE64_INVERSE_ALPHABET_URL = tmp_3;
  }
}
function toHexString_0(_this__u8e3s4) {
  // Inline function 'kotlin.text.toHexString' call
  var format = Companion_getInstance().ek_1;
  return toHexString(_UByteArray___get_storage__impl__d4kctt(_this__u8e3s4), format);
}
function hexToByteArray_0(hexString) {
  return hexToByteArray(hexString, Companion_getInstance().ek_1);
}
function toHexString_1(_this__u8e3s4) {
  return toHexString(_this__u8e3s4, Companion_getInstance().ek_1);
}
function get_defaultCryptoService() {
  _init_properties_CryptoService_kt__asho3m();
  return defaultCryptoService;
}
var defaultCryptoService;
function defaultCryptoService$1() {
  this.o5p_1 = JsAesService_getInstance();
  this.p5p_1 = JsRsaService_getInstance();
  this.q5p_1 = JsStrongRandom_instance;
  this.r5p_1 = JsDigestService_instance;
  this.s5p_1 = JsHmacService_instance;
}
protoOf(defaultCryptoService$1).w5k = function () {
  return this.o5p_1;
};
protoOf(defaultCryptoService$1).x5k = function () {
  return this.p5p_1;
};
protoOf(defaultCryptoService$1).y5k = function () {
  return this.q5p_1;
};
protoOf(defaultCryptoService$1).z5k = function () {
  return this.r5p_1;
};
protoOf(defaultCryptoService$1).a5l = function () {
  return this.s5p_1;
};
var properties_initialized_CryptoService_kt_bke7q4;
function _init_properties_CryptoService_kt__asho3m() {
  if (!properties_initialized_CryptoService_kt_bke7q4) {
    properties_initialized_CryptoService_kt_bke7q4 = true;
    defaultCryptoService = new defaultCryptoService$1();
  }
}
function subtleAlgorithmNameFor($this, algorithm) {
  var tmp;
  if (equals(algorithm, CbcWithPkcs7Padding_instance)) {
    tmp = 'AES-CBC';
  } else {
    noWhenBranchMatchedException();
  }
  return tmp;
}
function generateKeyParams($this, algorithm, keySize) {
  return json([to('name', subtleAlgorithmNameFor($this, algorithm)), to('length', keySize.o5k_1)]);
}
function loadKeyParams($this, algorithm) {
  return json([to('name', subtleAlgorithmNameFor($this, algorithm))]);
}
function encryptionParam($this, algorithm, iv) {
  return json([to('name', subtleAlgorithmNameFor($this, algorithm)), to('iv', iv)]);
}
function $generateKeyCOROUTINE$2(_this__u8e3s4, algorithm, size, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.b5q_1 = _this__u8e3s4;
  this.c5q_1 = algorithm;
  this.d5q_1 = size;
}
protoOf($generateKeyCOROUTINE$2).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.generateKey(generateKeyParams(this.b5q_1, this.c5q_1, this.d5q_1), true, this.b5q_1.f5q_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return new AesKey(ARGUMENT, this.c5q_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $exportKeyCOROUTINE$3(_this__u8e3s4, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.o5q_1 = _this__u8e3s4;
  this.p5q_1 = key;
}
protoOf($exportKeyCOROUTINE$3).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.exportKey('raw', this.p5q_1.q5q_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult instanceof ArrayBuffer ? suspendResult : THROW_CCE();
          return toByteArray_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadKeyCOROUTINE$4(_this__u8e3s4, algorithm, bytes, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.a5r_1 = _this__u8e3s4;
  this.b5r_1 = algorithm;
  this.c5r_1 = bytes;
}
protoOf($loadKeyCOROUTINE$4).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.importKey('raw', toArrayBuffer(this.c5r_1), loadKeyParams(this.a5r_1, this.b5r_1), true, this.a5r_1.f5q_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return new AesKey(ARGUMENT, this.b5r_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $encryptCOROUTINE$5(_this__u8e3s4, data, key, iv, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.l5r_1 = _this__u8e3s4;
  this.m5r_1 = data;
  this.n5r_1 = key;
  this.o5r_1 = iv;
}
protoOf($encryptCOROUTINE$5).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          var tmp_0 = this;
          var tmp0_elvis_lhs = this.o5r_1;
          tmp_0.p5r_1 = tmp0_elvis_lhs == null ? JsStrongRandom_instance.u5o(16) : tmp0_elvis_lhs;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.encrypt(encryptionParam(this.l5r_1, this.n5r_1.r5q_1, toArrayBuffer(this.p5r_1)), this.n5r_1.q5q_1, toArrayBuffer(this.m5r_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var encrypted = suspendResult;
          var this_0 = this.p5r_1;
          var elements = toByteArray_0(encrypted);
          return primitiveArrayConcat([this_0, elements]);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $decryptCOROUTINE$6(_this__u8e3s4, ivAndEncryptedData, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.y5r_1 = _this__u8e3s4;
  this.z5r_1 = ivAndEncryptedData;
  this.a5s_1 = key;
}
protoOf($decryptCOROUTINE$6).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.b5s_1 = toArrayBuffer(this.z5r_1);
          this.c5s_1 = this.b5s_1.slice(0, 16);
          this.d5s_1 = this.b5s_1.slice(16);
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.decrypt(encryptionParam(this.y5r_1, this.a5s_1.r5q_1, this.c5s_1), this.a5s_1.q5q_1, this.d5s_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toByteArray_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function JsAesService() {
  JsAesService_instance = this;
  this.e5q_1 = 'raw';
  var tmp = this;
  // Inline function 'kotlin.arrayOf' call
  // Inline function 'kotlin.js.unsafeCast' call
  // Inline function 'kotlin.js.asDynamic' call
  tmp.f5q_1 = ['encrypt', 'decrypt'];
}
protoOf(JsAesService).p5k = function (algorithm, size, $completion) {
  var tmp = new $generateKeyCOROUTINE$2(this, algorithm, size, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsAesService).r5k = function (key, $completion) {
  var tmp = new $exportKeyCOROUTINE$3(this, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsAesService).s5k = function (algorithm, bytes, $completion) {
  var tmp = new $loadKeyCOROUTINE$4(this, algorithm, bytes, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsAesService).t5k = function (data, key, iv, $completion) {
  var tmp = new $encryptCOROUTINE$5(this, data, key, iv, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsAesService).v5k = function (ivAndEncryptedData, key, $completion) {
  var tmp = new $decryptCOROUTINE$6(this, ivAndEncryptedData, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
var JsAesService_instance;
function JsAesService_getInstance() {
  if (JsAesService_instance == null)
    new JsAesService();
  return JsAesService_instance;
}
function $sha256COROUTINE$7(_this__u8e3s4, data, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.m5s_1 = _this__u8e3s4;
  this.n5s_1 = data;
}
protoOf($sha256COROUTINE$7).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.digest('SHA-256', toArrayBuffer(this.n5s_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toByteArray_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $sha512COROUTINE$8(_this__u8e3s4, data, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.w5s_1 = _this__u8e3s4;
  this.x5s_1 = data;
}
protoOf($sha512COROUTINE$8).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.digest('SHA-512', toArrayBuffer(this.x5s_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toByteArray_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function JsDigestService() {
}
protoOf(JsDigestService).y5s = function (data, $completion) {
  var tmp = new $sha256COROUTINE$7(this, data, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsDigestService).z5s = function (data, $completion) {
  var tmp = new $sha512COROUTINE$8(this, data, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
var JsDigestService_instance;
function JsDigestService_getInstance() {
  return JsDigestService_instance;
}
function paramsForAlgorithm($this, algorithm, keySize) {
  var tmp = to('name', 'HMAC');
  var tmp_0;
  if (equals(algorithm, HmacSha512_instance)) {
    tmp_0 = 'SHA-512';
  } else if (equals(algorithm, HmacSha256_instance)) {
    tmp_0 = 'SHA-256';
  } else {
    noWhenBranchMatchedException();
  }
  return json([tmp, to('hash', tmp_0), to('length', imul(keySize, 8))]);
}
function exportRawKey($this, rawKey, $completion) {
  var tmp = new $exportRawKeyCOROUTINE$11($this, rawKey, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
}
function $generateKeyCOROUTINE$9(_this__u8e3s4, algorithm, keySize, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.s5t_1 = _this__u8e3s4;
  this.t5t_1 = algorithm;
  this.u5t_1 = keySize;
}
protoOf($generateKeyCOROUTINE$9).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 3;
          if (!(this.u5t_1 == null || this.u5t_1 >= this.t5t_1.h5m())) {
            var message = 'Invalid key size for ' + toString(this.t5t_1) + '. A minimal length of ' + this.t5t_1.h5m() + ' is required';
            throw IllegalArgumentException_init_$Create$(toString(message));
          }

          var tmp_0 = this;
          var tmp0_elvis_lhs = this.u5t_1;
          tmp_0.v5t_1 = tmp0_elvis_lhs == null ? this.t5t_1.g5m() : tmp0_elvis_lhs;
          this.f9_1 = 1;
          var tmp_1 = get_jsCrypto().subtle;
          var tmp1_elvis_lhs = this.u5t_1;
          var tmp_2 = paramsForAlgorithm(this.s5t_1, this.t5t_1, tmp1_elvis_lhs == null ? this.t5t_1.g5m() : tmp1_elvis_lhs);
          var this_0 = ['sign', 'verify'];
          suspendResult = await_0(tmp_1.generateKey(tmp_2, true, this_0), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          this.w5t_1 = suspendResult;
          this.f9_1 = 2;
          suspendResult = exportRawKey(this.s5t_1, this.w5t_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 2:
          var ARGUMENT = suspendResult;
          var generatedKeySize = ARGUMENT.byteLength;
          if (!(generatedKeySize === this.v5t_1))
            throw AssertionError_init_$Create$('Invalid key size for algorithm ' + toString(this.t5t_1) + ', expected ' + this.v5t_1 + ' got ' + generatedKeySize);
          return new HmacKey(this.w5t_1, generatedKeySize, this.t5t_1);
        case 3:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 3) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $exportKeyCOROUTINE$10(_this__u8e3s4, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.f5u_1 = _this__u8e3s4;
  this.g5u_1 = key;
}
protoOf($exportKeyCOROUTINE$10).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = exportRawKey(this.f5u_1, this.g5u_1.h5u_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toByteArray_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $exportRawKeyCOROUTINE$11(_this__u8e3s4, rawKey, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.i5t_1 = _this__u8e3s4;
  this.j5t_1 = rawKey;
}
protoOf($exportRawKeyCOROUTINE$11).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.exportKey('raw', this.j5t_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult instanceof ArrayBuffer ? suspendResult : THROW_CCE();
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadKeyCOROUTINE$12(_this__u8e3s4, algorithm, bytes, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.s5u_1 = _this__u8e3s4;
  this.t5u_1 = algorithm;
  this.u5u_1 = bytes;
}
protoOf($loadKeyCOROUTINE$12).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          if (!(this.u5u_1.length >= this.t5u_1.h5m())) {
            var message = 'Invalid key length for algorithm ' + toString(this.t5u_1) + ': got ' + this.u5u_1.length + ' but at least ' + this.t5u_1.h5m() + ' expected';
            throw IllegalArgumentException_init_$Create$(toString(message));
          }

          this.f9_1 = 1;
          var tmp_0 = get_jsCrypto().subtle;
          var tmp_1 = toArrayBuffer(this.u5u_1);
          var tmp_2 = paramsForAlgorithm(this.s5u_1, this.t5u_1, this.u5u_1.length);
          var this_0 = ['sign', 'verify'];
          suspendResult = await_0(tmp_0.importKey('raw', tmp_1, tmp_2, true, this_0), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return new HmacKey(ARGUMENT, this.u5u_1.length, this.t5u_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $signCOROUTINE$13(_this__u8e3s4, data, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.d5v_1 = _this__u8e3s4;
  this.e5v_1 = data;
  this.f5v_1 = key;
}
protoOf($signCOROUTINE$13).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.sign(paramsForAlgorithm(this.d5v_1, this.f5v_1.j5u_1, this.f5v_1.i5u_1), this.f5v_1.h5u_1, toArrayBuffer(this.e5v_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toByteArray_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function JsHmacService() {
  this.g5v_1 = 'HMAC';
  this.h5v_1 = 'raw';
}
protoOf(JsHmacService).b5l = function (algorithm, keySize, $completion) {
  var tmp = new $generateKeyCOROUTINE$9(this, algorithm, keySize, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsHmacService).d5l = function (key, $completion) {
  var tmp = new $exportKeyCOROUTINE$10(this, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsHmacService).e5l = function (algorithm, bytes, $completion) {
  var tmp = new $loadKeyCOROUTINE$12(this, algorithm, bytes, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsHmacService).f5l = function (data, key, $completion) {
  var tmp = new $signCOROUTINE$13(this, data, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsHmacService).g5l = function (signature, data, key, $completion) {
  return await_0(get_jsCrypto().subtle.verify(paramsForAlgorithm(this, key.j5u_1, key.i5u_1), key.h5u_1, toArrayBuffer(signature), toArrayBuffer(data)), $completion);
};
var JsHmacService_instance;
function JsHmacService_getInstance() {
  return JsHmacService_instance;
}
function importRawPrivateKeyPkcs8($this, algorithm, privateKeyPkcs8, $completion) {
  var params = importAlgorithmParams($this, algorithm);
  return await_0(get_jsCrypto().subtle.importKey('pkcs8', toArrayBuffer(privateKeyPkcs8), params, true, privateKeyUses($this, algorithm)), $completion);
}
function keyGenParams($this, keySize, algorithm) {
  return json([to('name', algorithmName($this, algorithm)), to('modulusLength', keySize.d5n_1), to('publicExponent', $this.i5v_1), to('hash', json([to('name', hashName($this, algorithm))]))]);
}
function importAlgorithmParams($this, algorithm) {
  return json([to('name', algorithmName($this, algorithm)), to('hash', json([to('name', hashName($this, algorithm))]))]);
}
function encryptionAlgorithmParams($this, algorithm) {
  var tmp;
  if (equals(algorithm, OaepWithSha1_instance) || equals(algorithm, OaepWithSha256_instance)) {
    tmp = json([to('name', algorithmName($this, algorithm))]);
  } else {
    noWhenBranchMatchedException();
  }
  return tmp;
}
function signatureAlgorithmParams($this, algorithm) {
  var tmp;
  if (equals(algorithm, PssWithSha256_instance)) {
    tmp = json([to('name', algorithmName($this, algorithm)), to('saltLength', 32)]);
  } else {
    noWhenBranchMatchedException();
  }
  return tmp;
}
function algorithmName($this, algorithm) {
  var tmp;
  if (equals(algorithm, OaepWithSha1_instance) || equals(algorithm, OaepWithSha256_instance)) {
    tmp = 'RSA-OAEP';
  } else if (equals(algorithm, PssWithSha256_instance)) {
    tmp = 'RSA-PSS';
  } else {
    noWhenBranchMatchedException();
  }
  return tmp;
}
function hashName($this, algorithm) {
  var tmp;
  if (equals(algorithm, OaepWithSha1_instance)) {
    tmp = 'SHA-1';
  } else if (equals(algorithm, OaepWithSha256_instance) || equals(algorithm, PssWithSha256_instance)) {
    tmp = 'SHA-256';
  } else {
    noWhenBranchMatchedException();
  }
  return tmp;
}
function keyPairUses($this, algorithm) {
  var tmp;
  if (isInterface(algorithm, RsaEncryptionAlgorithm)) {
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    tmp = ['encrypt', 'decrypt'];
  } else {
    if (isInterface(algorithm, RsaSignatureAlgorithm)) {
      // Inline function 'kotlin.arrayOf' call
      // Inline function 'kotlin.js.unsafeCast' call
      // Inline function 'kotlin.js.asDynamic' call
      tmp = ['sign', 'verify'];
    } else {
      noWhenBranchMatchedException();
    }
  }
  return tmp;
}
function privateKeyUses($this, algorithm) {
  var tmp;
  if (isInterface(algorithm, RsaEncryptionAlgorithm)) {
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    tmp = ['decrypt'];
  } else {
    if (isInterface(algorithm, RsaSignatureAlgorithm)) {
      // Inline function 'kotlin.arrayOf' call
      // Inline function 'kotlin.js.unsafeCast' call
      // Inline function 'kotlin.js.asDynamic' call
      tmp = ['sign'];
    } else {
      noWhenBranchMatchedException();
    }
  }
  return tmp;
}
function publicKeyUses($this, algorithm) {
  var tmp;
  if (isInterface(algorithm, RsaEncryptionAlgorithm)) {
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    tmp = ['encrypt'];
  } else {
    if (isInterface(algorithm, RsaSignatureAlgorithm)) {
      // Inline function 'kotlin.arrayOf' call
      // Inline function 'kotlin.js.unsafeCast' call
      // Inline function 'kotlin.js.asDynamic' call
      tmp = ['verify'];
    } else {
      noWhenBranchMatchedException();
    }
  }
  return tmp;
}
function JsRsaService$exportPrivateKeyJwk$lambda($this$parsingDynamic) {
  // Inline function 'kotlin.also' call
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs = $this$parsingDynamic.j5v_1['alg'];
  var tmp;
  if (tmp0_elvis_lhs == null) {
    throw new PlatformMethodException('Field ' + 'alg' + ' is missing');
  } else {
    tmp = tmp0_elvis_lhs;
  }
  var tmp_0 = tmp;
  var tmp1_elvis_lhs = (!(tmp_0 == null) ? typeof tmp_0 === 'string' : false) ? tmp_0 : null;
  var tmp_1;
  if (tmp1_elvis_lhs == null) {
    throw new PlatformMethodException('Field ' + 'alg' + ' is not of the expected type');
  } else {
    tmp_1 = tmp1_elvis_lhs;
  }
  var tmp0_alg = tmp_1;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_0 = $this$parsingDynamic.j5v_1['d'];
  var tmp_2;
  if (tmp0_elvis_lhs_0 == null) {
    throw new PlatformMethodException('Field ' + 'd' + ' is missing');
  } else {
    tmp_2 = tmp0_elvis_lhs_0;
  }
  var tmp_3 = tmp_2;
  var tmp1_elvis_lhs_0 = (!(tmp_3 == null) ? typeof tmp_3 === 'string' : false) ? tmp_3 : null;
  var tmp_4;
  if (tmp1_elvis_lhs_0 == null) {
    throw new PlatformMethodException('Field ' + 'd' + ' is not of the expected type');
  } else {
    tmp_4 = tmp1_elvis_lhs_0;
  }
  var tmp1_d = tmp_4;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_1 = $this$parsingDynamic.j5v_1['dp'];
  var tmp_5;
  if (tmp0_elvis_lhs_1 == null) {
    throw new PlatformMethodException('Field ' + 'dp' + ' is missing');
  } else {
    tmp_5 = tmp0_elvis_lhs_1;
  }
  var tmp_6 = tmp_5;
  var tmp1_elvis_lhs_1 = (!(tmp_6 == null) ? typeof tmp_6 === 'string' : false) ? tmp_6 : null;
  var tmp_7;
  if (tmp1_elvis_lhs_1 == null) {
    throw new PlatformMethodException('Field ' + 'dp' + ' is not of the expected type');
  } else {
    tmp_7 = tmp1_elvis_lhs_1;
  }
  var tmp2_dp = tmp_7;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_2 = $this$parsingDynamic.j5v_1['dq'];
  var tmp_8;
  if (tmp0_elvis_lhs_2 == null) {
    throw new PlatformMethodException('Field ' + 'dq' + ' is missing');
  } else {
    tmp_8 = tmp0_elvis_lhs_2;
  }
  var tmp_9 = tmp_8;
  var tmp1_elvis_lhs_2 = (!(tmp_9 == null) ? typeof tmp_9 === 'string' : false) ? tmp_9 : null;
  var tmp_10;
  if (tmp1_elvis_lhs_2 == null) {
    throw new PlatformMethodException('Field ' + 'dq' + ' is not of the expected type');
  } else {
    tmp_10 = tmp1_elvis_lhs_2;
  }
  var tmp3_dq = tmp_10;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_3 = $this$parsingDynamic.j5v_1['e'];
  var tmp_11;
  if (tmp0_elvis_lhs_3 == null) {
    throw new PlatformMethodException('Field ' + 'e' + ' is missing');
  } else {
    tmp_11 = tmp0_elvis_lhs_3;
  }
  var tmp_12 = tmp_11;
  var tmp1_elvis_lhs_3 = (!(tmp_12 == null) ? typeof tmp_12 === 'string' : false) ? tmp_12 : null;
  var tmp_13;
  if (tmp1_elvis_lhs_3 == null) {
    throw new PlatformMethodException('Field ' + 'e' + ' is not of the expected type');
  } else {
    tmp_13 = tmp1_elvis_lhs_3;
  }
  var tmp4_e = tmp_13;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_4 = $this$parsingDynamic.j5v_1['n'];
  var tmp_14;
  if (tmp0_elvis_lhs_4 == null) {
    throw new PlatformMethodException('Field ' + 'n' + ' is missing');
  } else {
    tmp_14 = tmp0_elvis_lhs_4;
  }
  var tmp_15 = tmp_14;
  var tmp1_elvis_lhs_4 = (!(tmp_15 == null) ? typeof tmp_15 === 'string' : false) ? tmp_15 : null;
  var tmp_16;
  if (tmp1_elvis_lhs_4 == null) {
    throw new PlatformMethodException('Field ' + 'n' + ' is not of the expected type');
  } else {
    tmp_16 = tmp1_elvis_lhs_4;
  }
  var tmp5_n = tmp_16;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_5 = $this$parsingDynamic.j5v_1['p'];
  var tmp_17;
  if (tmp0_elvis_lhs_5 == null) {
    throw new PlatformMethodException('Field ' + 'p' + ' is missing');
  } else {
    tmp_17 = tmp0_elvis_lhs_5;
  }
  var tmp_18 = tmp_17;
  var tmp1_elvis_lhs_5 = (!(tmp_18 == null) ? typeof tmp_18 === 'string' : false) ? tmp_18 : null;
  var tmp_19;
  if (tmp1_elvis_lhs_5 == null) {
    throw new PlatformMethodException('Field ' + 'p' + ' is not of the expected type');
  } else {
    tmp_19 = tmp1_elvis_lhs_5;
  }
  var tmp6_p = tmp_19;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_6 = $this$parsingDynamic.j5v_1['q'];
  var tmp_20;
  if (tmp0_elvis_lhs_6 == null) {
    throw new PlatformMethodException('Field ' + 'q' + ' is missing');
  } else {
    tmp_20 = tmp0_elvis_lhs_6;
  }
  var tmp_21 = tmp_20;
  var tmp1_elvis_lhs_6 = (!(tmp_21 == null) ? typeof tmp_21 === 'string' : false) ? tmp_21 : null;
  var tmp_22;
  if (tmp1_elvis_lhs_6 == null) {
    throw new PlatformMethodException('Field ' + 'q' + ' is not of the expected type');
  } else {
    tmp_22 = tmp1_elvis_lhs_6;
  }
  var tmp7_q = tmp_22;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_7 = $this$parsingDynamic.j5v_1['qi'];
  var tmp_23;
  if (tmp0_elvis_lhs_7 == null) {
    throw new PlatformMethodException('Field ' + 'qi' + ' is missing');
  } else {
    tmp_23 = tmp0_elvis_lhs_7;
  }
  var tmp_24 = tmp_23;
  var tmp1_elvis_lhs_7 = (!(tmp_24 == null) ? typeof tmp_24 === 'string' : false) ? tmp_24 : null;
  var tmp_25;
  if (tmp1_elvis_lhs_7 == null) {
    throw new PlatformMethodException('Field ' + 'qi' + ' is not of the expected type');
  } else {
    tmp_25 = tmp1_elvis_lhs_7;
  }
  var tmp8_qi = tmp_25;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expectArray' call
  // Inline function 'kotlin.also' call
  var tmp0_elvis_lhs_8 = $this$parsingDynamic.j5v_1['key_ops'];
  var tmp_26;
  if (tmp0_elvis_lhs_8 == null) {
    throw new PlatformMethodException('Field ' + 'key_ops' + ' is missing');
  } else {
    tmp_26 = tmp0_elvis_lhs_8;
  }
  var tmp_27 = tmp_26;
  var tmp1_elvis_lhs_8 = (!(tmp_27 == null) ? isArray(tmp_27) : false) ? tmp_27 : null;
  var tmp_28;
  if (tmp1_elvis_lhs_8 == null) {
    throw new PlatformMethodException('Field ' + 'key_ops' + ' is not of the expected type');
  } else {
    tmp_28 = tmp1_elvis_lhs_8;
  }
  var this_0 = tmp_28;
  // Inline function 'kotlin.contracts.contract' call
  // Inline function 'com.icure.kryptom.js.DynamicParser.expectArray.<anonymous>' call
  var inductionVariable = 0;
  var last = this_0.length - 1 | 0;
  if (inductionVariable <= last)
    do {
      var i = inductionVariable;
      inductionVariable = inductionVariable + 1 | 0;
      var tmp_29 = this_0[i];
      if ((typeof tmp_29 === 'string' ? tmp_29 : null) == null)
        throw new PlatformMethodException('Field ' + 'key_ops' + '[' + i + '] is not of the expected type');
    }
     while (inductionVariable <= last);
  var tmp9_key_ops = toSet(this_0);
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_9 = $this$parsingDynamic.j5v_1['ext'];
  var tmp_30;
  if (tmp0_elvis_lhs_9 == null) {
    throw new PlatformMethodException('Field ' + 'ext' + ' is missing');
  } else {
    tmp_30 = tmp0_elvis_lhs_9;
  }
  var tmp_31 = tmp_30;
  var tmp1_elvis_lhs_9 = (!(tmp_31 == null) ? typeof tmp_31 === 'boolean' : false) ? tmp_31 : null;
  var tmp_32;
  if (tmp1_elvis_lhs_9 == null) {
    throw new PlatformMethodException('Field ' + 'ext' + ' is not of the expected type');
  } else {
    tmp_32 = tmp1_elvis_lhs_9;
  }
  var tmp10_ext = tmp_32;
  var this_1 = new PrivateRsaKeyJwk(tmp0_alg, tmp1_d, tmp2_dp, tmp3_dq, tmp4_e, tmp10_ext, tmp9_key_ops, tmp5_n, tmp6_p, tmp7_q, tmp8_qi);
  // Inline function 'kotlin.contracts.contract' call
  // Inline function 'com.icure.kryptom.crypto.JsRsaService.exportPrivateKeyJwk.<anonymous>.<anonymous>' call
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_10 = $this$parsingDynamic.j5v_1['kty'];
  var tmp_33;
  if (tmp0_elvis_lhs_10 == null) {
    throw new PlatformMethodException('Field ' + 'kty' + ' is missing');
  } else {
    tmp_33 = tmp0_elvis_lhs_10;
  }
  var tmp_34 = tmp_33;
  var tmp1_elvis_lhs_10 = (!(tmp_34 == null) ? typeof tmp_34 === 'string' : false) ? tmp_34 : null;
  var tmp_35;
  if (tmp1_elvis_lhs_10 == null) {
    throw new PlatformMethodException('Field ' + 'kty' + ' is not of the expected type');
  } else {
    tmp_35 = tmp1_elvis_lhs_10;
  }
  if (!(tmp_35 === 'RSA')) {
    throw new PlatformMethodException('Key type should be RSA');
  }
  return this_1;
}
function JsRsaService$exportPublicKeyJwk$lambda($this$parsingDynamic) {
  // Inline function 'kotlin.also' call
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs = $this$parsingDynamic.j5v_1['alg'];
  var tmp;
  if (tmp0_elvis_lhs == null) {
    throw new PlatformMethodException('Field ' + 'alg' + ' is missing');
  } else {
    tmp = tmp0_elvis_lhs;
  }
  var tmp_0 = tmp;
  var tmp1_elvis_lhs = (!(tmp_0 == null) ? typeof tmp_0 === 'string' : false) ? tmp_0 : null;
  var tmp_1;
  if (tmp1_elvis_lhs == null) {
    throw new PlatformMethodException('Field ' + 'alg' + ' is not of the expected type');
  } else {
    tmp_1 = tmp1_elvis_lhs;
  }
  var tmp0_alg = tmp_1;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_0 = $this$parsingDynamic.j5v_1['e'];
  var tmp_2;
  if (tmp0_elvis_lhs_0 == null) {
    throw new PlatformMethodException('Field ' + 'e' + ' is missing');
  } else {
    tmp_2 = tmp0_elvis_lhs_0;
  }
  var tmp_3 = tmp_2;
  var tmp1_elvis_lhs_0 = (!(tmp_3 == null) ? typeof tmp_3 === 'string' : false) ? tmp_3 : null;
  var tmp_4;
  if (tmp1_elvis_lhs_0 == null) {
    throw new PlatformMethodException('Field ' + 'e' + ' is not of the expected type');
  } else {
    tmp_4 = tmp1_elvis_lhs_0;
  }
  var tmp1_e = tmp_4;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_1 = $this$parsingDynamic.j5v_1['n'];
  var tmp_5;
  if (tmp0_elvis_lhs_1 == null) {
    throw new PlatformMethodException('Field ' + 'n' + ' is missing');
  } else {
    tmp_5 = tmp0_elvis_lhs_1;
  }
  var tmp_6 = tmp_5;
  var tmp1_elvis_lhs_1 = (!(tmp_6 == null) ? typeof tmp_6 === 'string' : false) ? tmp_6 : null;
  var tmp_7;
  if (tmp1_elvis_lhs_1 == null) {
    throw new PlatformMethodException('Field ' + 'n' + ' is not of the expected type');
  } else {
    tmp_7 = tmp1_elvis_lhs_1;
  }
  var tmp2_n = tmp_7;
  // Inline function 'com.icure.kryptom.js.DynamicParser.expectArray' call
  // Inline function 'kotlin.also' call
  var tmp0_elvis_lhs_2 = $this$parsingDynamic.j5v_1['key_ops'];
  var tmp_8;
  if (tmp0_elvis_lhs_2 == null) {
    throw new PlatformMethodException('Field ' + 'key_ops' + ' is missing');
  } else {
    tmp_8 = tmp0_elvis_lhs_2;
  }
  var tmp_9 = tmp_8;
  var tmp1_elvis_lhs_2 = (!(tmp_9 == null) ? isArray(tmp_9) : false) ? tmp_9 : null;
  var tmp_10;
  if (tmp1_elvis_lhs_2 == null) {
    throw new PlatformMethodException('Field ' + 'key_ops' + ' is not of the expected type');
  } else {
    tmp_10 = tmp1_elvis_lhs_2;
  }
  var this_0 = tmp_10;
  // Inline function 'kotlin.contracts.contract' call
  // Inline function 'com.icure.kryptom.js.DynamicParser.expectArray.<anonymous>' call
  var inductionVariable = 0;
  var last = this_0.length - 1 | 0;
  if (inductionVariable <= last)
    do {
      var i = inductionVariable;
      inductionVariable = inductionVariable + 1 | 0;
      var tmp_11 = this_0[i];
      if ((typeof tmp_11 === 'string' ? tmp_11 : null) == null)
        throw new PlatformMethodException('Field ' + 'key_ops' + '[' + i + '] is not of the expected type');
    }
     while (inductionVariable <= last);
  var tmp3_key_ops = toSet(this_0);
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_3 = $this$parsingDynamic.j5v_1['ext'];
  var tmp_12;
  if (tmp0_elvis_lhs_3 == null) {
    throw new PlatformMethodException('Field ' + 'ext' + ' is missing');
  } else {
    tmp_12 = tmp0_elvis_lhs_3;
  }
  var tmp_13 = tmp_12;
  var tmp1_elvis_lhs_3 = (!(tmp_13 == null) ? typeof tmp_13 === 'boolean' : false) ? tmp_13 : null;
  var tmp_14;
  if (tmp1_elvis_lhs_3 == null) {
    throw new PlatformMethodException('Field ' + 'ext' + ' is not of the expected type');
  } else {
    tmp_14 = tmp1_elvis_lhs_3;
  }
  var tmp4_ext = tmp_14;
  var this_1 = new PublicRsaKeyJwk(tmp0_alg, tmp1_e, tmp4_ext, tmp3_key_ops, tmp2_n);
  // Inline function 'kotlin.contracts.contract' call
  // Inline function 'com.icure.kryptom.crypto.JsRsaService.exportPublicKeyJwk.<anonymous>.<anonymous>' call
  // Inline function 'com.icure.kryptom.js.DynamicParser.expect' call
  var tmp0_elvis_lhs_4 = $this$parsingDynamic.j5v_1['kty'];
  var tmp_15;
  if (tmp0_elvis_lhs_4 == null) {
    throw new PlatformMethodException('Field ' + 'kty' + ' is missing');
  } else {
    tmp_15 = tmp0_elvis_lhs_4;
  }
  var tmp_16 = tmp_15;
  var tmp1_elvis_lhs_4 = (!(tmp_16 == null) ? typeof tmp_16 === 'string' : false) ? tmp_16 : null;
  var tmp_17;
  if (tmp1_elvis_lhs_4 == null) {
    throw new PlatformMethodException('Field ' + 'kty' + ' is not of the expected type');
  } else {
    tmp_17 = tmp1_elvis_lhs_4;
  }
  if (!(tmp_17 === 'RSA')) {
    throw new PlatformMethodException('Key type should be RSA');
  }
  return this_1;
}
function $generateKeyPairCOROUTINE$14(_this__u8e3s4, algorithm, keySize, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.s5v_1 = _this__u8e3s4;
  this.t5v_1 = algorithm;
  this.u5v_1 = keySize;
}
protoOf($generateKeyPairCOROUTINE$14).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.generateKey(keyGenParams(this.s5v_1, this.u5v_1, this.t5v_1), true, keyPairUses(this.s5v_1, this.t5v_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var pair = suspendResult;
          var tmp0_elvis_lhs = pair['privateKey'];
          var tmp_0;
          if (tmp0_elvis_lhs == null) {
            throw new PlatformMethodException('Pair returned by generator should have private key');
          } else {
            tmp_0 = tmp0_elvis_lhs;
          }

          var privateKey = new PrivateRsaKey(tmp_0, this.t5v_1);
          var tmp1_elvis_lhs = pair['publicKey'];
          var tmp_1;
          if (tmp1_elvis_lhs == null) {
            throw new PlatformMethodException('Pair returned by generator should have public key');
          } else {
            tmp_1 = tmp1_elvis_lhs;
          }

          var publicKey = new PublicRsaKey(tmp_1, this.t5v_1);
          return new RsaKeypair(privateKey, publicKey);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $exportPrivateKeyPkcs8COROUTINE$15(_this__u8e3s4, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.d5w_1 = _this__u8e3s4;
  this.e5w_1 = key;
}
protoOf($exportPrivateKeyPkcs8COROUTINE$15).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.exportKey('pkcs8', this.e5w_1.w5m_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult instanceof ArrayBuffer ? suspendResult : THROW_CCE();
          return toByteArray_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $exportPublicKeySpkiCOROUTINE$16(_this__u8e3s4, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.n5w_1 = _this__u8e3s4;
  this.o5w_1 = key;
}
protoOf($exportPublicKeySpkiCOROUTINE$16).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.exportKey('spki', this.o5w_1.y5m_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult instanceof ArrayBuffer ? suspendResult : THROW_CCE();
          return toByteArray_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadKeyPairPkcs8COROUTINE$17(_this__u8e3s4, algorithm, privateKeyPkcs8, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.x5w_1 = _this__u8e3s4;
  this.y5w_1 = algorithm;
  this.z5w_1 = privateKeyPkcs8;
}
protoOf($loadKeyPairPkcs8COROUTINE$17).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 4;
          this.f9_1 = 1;
          suspendResult = importRawPrivateKeyPkcs8(this.x5w_1, this.y5w_1, this.z5w_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          this.a5x_1 = suspendResult;
          this.f9_1 = 2;
          suspendResult = await_0(get_jsCrypto().subtle.exportKey('jwk', this.a5x_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 2:
          this.b5x_1 = suspendResult;
          this.b5x_1.d = undefined;
          this.b5x_1.dp = undefined;
          this.b5x_1.dq = undefined;
          this.b5x_1.q = undefined;
          this.b5x_1.qi = undefined;
          this.b5x_1.key_ops = publicKeyUses(this.x5w_1, this.y5w_1);
          this.f9_1 = 3;
          suspendResult = await_0(get_jsCrypto().subtle.importKey('jwk', this.b5x_1, importAlgorithmParams(this.x5w_1, this.y5w_1), true, publicKeyUses(this.x5w_1, this.y5w_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 3:
          var rawPublicKey = suspendResult;
          return new RsaKeypair(new PrivateRsaKey(this.a5x_1, this.y5w_1), new PublicRsaKey(rawPublicKey, this.y5w_1));
        case 4:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 4) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadPrivateKeyPkcs8COROUTINE$18(_this__u8e3s4, algorithm, privateKeyPkcs8, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.k5x_1 = _this__u8e3s4;
  this.l5x_1 = algorithm;
  this.m5x_1 = privateKeyPkcs8;
}
protoOf($loadPrivateKeyPkcs8COROUTINE$18).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = importRawPrivateKeyPkcs8(this.k5x_1, this.l5x_1, this.m5x_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return new PrivateRsaKey(ARGUMENT, this.l5x_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadPublicKeySpkiCOROUTINE$19(_this__u8e3s4, algorithm, publicKeySpki, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.v5x_1 = _this__u8e3s4;
  this.w5x_1 = algorithm;
  this.x5x_1 = publicKeySpki;
}
protoOf($loadPublicKeySpkiCOROUTINE$19).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.importKey('spki', this.x5x_1, importAlgorithmParams(this.v5x_1, this.w5x_1), true, publicKeyUses(this.v5x_1, this.w5x_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var rawPublicKey = suspendResult;
          return new PublicRsaKey(rawPublicKey, this.w5x_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $encryptCOROUTINE$20(_this__u8e3s4, data, publicKey, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.g5y_1 = _this__u8e3s4;
  this.h5y_1 = data;
  this.i5y_1 = publicKey;
}
protoOf($encryptCOROUTINE$20).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.encrypt(encryptionAlgorithmParams(this.g5y_1, this.i5y_1.z5m_1), this.i5y_1.y5m_1, toArrayBuffer(this.h5y_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toByteArray_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $decryptCOROUTINE$21(_this__u8e3s4, data, privateKey, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.r5y_1 = _this__u8e3s4;
  this.s5y_1 = data;
  this.t5y_1 = privateKey;
}
protoOf($decryptCOROUTINE$21).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.decrypt(encryptionAlgorithmParams(this.r5y_1, this.t5y_1.x5m_1), this.t5y_1.w5m_1, toArrayBuffer(this.s5y_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toByteArray_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $signCOROUTINE$22(_this__u8e3s4, data, privateKey, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.c5z_1 = _this__u8e3s4;
  this.d5z_1 = data;
  this.e5z_1 = privateKey;
}
protoOf($signCOROUTINE$22).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.sign(signatureAlgorithmParams(this.c5z_1, this.e5z_1.x5m_1), this.e5z_1.w5m_1, toArrayBuffer(this.d5z_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toByteArray_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $exportPrivateKeyJwkCOROUTINE$23(_this__u8e3s4, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.n5z_1 = _this__u8e3s4;
  this.o5z_1 = key;
}
protoOf($exportPrivateKeyJwkCOROUTINE$23).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.exportKey('jwk', this.o5z_1.w5m_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return parsingDynamic(ARGUMENT, JsRsaService$exportPrivateKeyJwk$lambda);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $exportPublicKeyJwkCOROUTINE$24(_this__u8e3s4, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.x5z_1 = _this__u8e3s4;
  this.y5z_1 = key;
}
protoOf($exportPublicKeyJwkCOROUTINE$24).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(get_jsCrypto().subtle.exportKey('jwk', this.y5z_1.y5m_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return parsingDynamic(ARGUMENT, JsRsaService$exportPublicKeyJwk$lambda);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadPrivateKeyJwkCOROUTINE$25(_this__u8e3s4, algorithm, privateKeyJwk, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.h60_1 = _this__u8e3s4;
  this.i60_1 = algorithm;
  this.j60_1 = privateKeyJwk;
}
protoOf($loadPrivateKeyJwkCOROUTINE$25).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          if (!(this.i60_1.o5m() === this.j60_1.h5l_1)) {
            var message = 'Algorithm of JWK does not match provided algorithm - ' + this.j60_1.h5l_1 + ' != ' + this.i60_1.o5m();
            throw IllegalArgumentException_init_$Create$(toString(message));
          }

          this.f9_1 = 1;
          var tmp_0 = get_jsCrypto().subtle;
          var tmp_1 = to('alg', this.j60_1.h5l_1);
          var tmp_2 = to('d', this.j60_1.i5l_1);
          var tmp_3 = to('dp', this.j60_1.j5l_1);
          var tmp_4 = to('dq', this.j60_1.k5l_1);
          var tmp_5 = to('e', this.j60_1.l5l_1);
          var tmp_6 = to('ext', this.j60_1.m5l_1);
          var this_0 = this.j60_1.n5l_1;
          suspendResult = await_0(tmp_0.importKey('jwk', json([tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, to('key_ops', copyToArray(this_0)), to('kty', this.j60_1.s5l_1), to('n', this.j60_1.o5l_1), to('p', this.j60_1.p5l_1), to('q', this.j60_1.q5l_1), to('qi', this.j60_1.r5l_1)]), importAlgorithmParams(this.h60_1, this.i60_1), true, privateKeyUses(this.h60_1, this.i60_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return new PrivateRsaKey(ARGUMENT, this.i60_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadPublicKeyJwkCOROUTINE$26(_this__u8e3s4, algorithm, publicKeyJwk, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.s60_1 = _this__u8e3s4;
  this.t60_1 = algorithm;
  this.u60_1 = publicKeyJwk;
}
protoOf($loadPublicKeyJwkCOROUTINE$26).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          if (!(this.t60_1.o5m() === this.u60_1.t5l_1)) {
            var message = 'Algorithm of JWK does not match provided algorithm - ' + this.u60_1.t5l_1 + ' != ' + this.t60_1.o5m();
            throw IllegalArgumentException_init_$Create$(toString(message));
          }

          this.f9_1 = 1;
          var tmp_0 = get_jsCrypto().subtle;
          var tmp_1 = to('alg', this.u60_1.t5l_1);
          var tmp_2 = to('e', this.u60_1.u5l_1);
          var tmp_3 = to('ext', this.u60_1.v5l_1);
          var this_0 = this.u60_1.w5l_1;
          suspendResult = await_0(tmp_0.importKey('jwk', json([tmp_1, tmp_2, tmp_3, to('key_ops', copyToArray(this_0)), to('kty', this.u60_1.y5l_1), to('n', this.u60_1.x5l_1)]), importAlgorithmParams(this.s60_1, this.t60_1), true, publicKeyUses(this.s60_1, this.t60_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return new PublicRsaKey(ARGUMENT, this.t60_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function JsRsaService() {
  JsRsaService_instance = this;
  var tmp = this;
  // Inline function 'kotlin.byteArrayOf' call
  var tmp$ret$0 = new Int8Array([1, 0, 1]);
  tmp.i5v_1 = new Uint8Array(toTypedArray(tmp$ret$0));
}
protoOf(JsRsaService).g5o = function (algorithm, keySize, $completion) {
  var tmp = new $generateKeyPairCOROUTINE$14(this, algorithm, keySize, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).q5n = function (key, $completion) {
  var tmp = new $exportPrivateKeyPkcs8COROUTINE$15(this, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).e5o = function (key, $completion) {
  var tmp = new $exportPublicKeySpkiCOROUTINE$16(this, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).j5o = function (algorithm, privateKeyPkcs8, $completion) {
  var tmp = new $loadKeyPairPkcs8COROUTINE$17(this, algorithm, privateKeyPkcs8, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).k5o = function (algorithm, privateKeyPkcs8, $completion) {
  var tmp = new $loadPrivateKeyPkcs8COROUTINE$18(this, algorithm, privateKeyPkcs8, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).n5o = function (algorithm, publicKeySpki, $completion) {
  var tmp = new $loadPublicKeySpkiCOROUTINE$19(this, algorithm, publicKeySpki, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).q5o = function (data, publicKey, $completion) {
  var tmp = new $encryptCOROUTINE$20(this, data, publicKey, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).r5o = function (data, privateKey, $completion) {
  var tmp = new $decryptCOROUTINE$21(this, data, privateKey, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).s5o = function (data, privateKey, $completion) {
  var tmp = new $signCOROUTINE$22(this, data, privateKey, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).t5o = function (signature, data, publicKey, $completion) {
  return await_0(get_jsCrypto().subtle.verify(signatureAlgorithmParams(this, publicKey.z5m_1), publicKey.y5m_1, toArrayBuffer(signature), toArrayBuffer(data)), $completion);
};
protoOf(JsRsaService).h5o = function (key, $completion) {
  var tmp = new $exportPrivateKeyJwkCOROUTINE$23(this, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).i5o = function (key, $completion) {
  var tmp = new $exportPublicKeyJwkCOROUTINE$24(this, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).l5o = function (algorithm, privateKeyJwk, $completion) {
  var tmp = new $loadPrivateKeyJwkCOROUTINE$25(this, algorithm, privateKeyJwk, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(JsRsaService).o5o = function (algorithm, publicKeyJwk, $completion) {
  var tmp = new $loadPublicKeyJwkCOROUTINE$26(this, algorithm, publicKeyJwk, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
var JsRsaService_instance;
function JsRsaService_getInstance() {
  if (JsRsaService_instance == null)
    new JsRsaService();
  return JsRsaService_instance;
}
function JsStrongRandom() {
}
protoOf(JsStrongRandom).v5o = function (array) {
  get_jsCrypto().getRandomValues(array);
};
protoOf(JsStrongRandom).w5o = function () {
  return get_jsCrypto().randomUUID();
};
var JsStrongRandom_instance;
function JsStrongRandom_getInstance() {
  return JsStrongRandom_instance;
}
function AesKey(cryptoKey, algorithm) {
  this.q5q_1 = cryptoKey;
  this.r5q_1 = algorithm;
}
function HmacKey(key, keySize, algorithm) {
  this.h5u_1 = key;
  this.i5u_1 = keySize;
  this.j5u_1 = algorithm;
}
function PrivateRsaKey(key, algorithm) {
  this.w5m_1 = key;
  this.x5m_1 = algorithm;
}
function PublicRsaKey(key, algorithm) {
  this.y5m_1 = key;
  this.z5m_1 = algorithm;
}
function toExternal(_this__u8e3s4) {
  var thisKey = _this__u8e3s4.q5q_1;
  var algorithmIdentifier = _this__u8e3s4.r5q_1.a5m();
  var tmp = {aesKey: thisKey, algorithm: algorithmIdentifier};
  return (!(tmp == null) ? !(tmp == null) : false) ? tmp : THROW_CCE();
}
function toKryptom(_this__u8e3s4) {
  return new AesKey(_this__u8e3s4.aesKey, Companion_instance.b5m(_this__u8e3s4.algorithm));
}
function toKryptom_0(_this__u8e3s4, algorithm) {
  if (!(_this__u8e3s4.algorithm === algorithm.a5m())) {
    throw AssertionError_init_$Create$('Algorithm mismatch: ' + _this__u8e3s4.algorithm + ' != ' + algorithm.a5m());
  }
  return new AesKey(_this__u8e3s4.aesKey, algorithm);
}
function adaptExternalCryptoService(service) {
  var tmp;
  if (service instanceof XServiceAdapter) {
    tmp = service.v60_1;
  } else {
    tmp = new ServiceAdapter(service);
  }
  return tmp;
}
function adaptCryptoServiceForExternal(service) {
  var tmp;
  if (service instanceof ServiceAdapter) {
    tmp = service.b61_1;
  } else {
    tmp = new XServiceAdapter(service);
  }
  return tmp;
}
function XServiceAdapter(service) {
  this.v60_1 = service;
  this.w60_1 = new XAesServiceAdapter(this.v60_1.w5k());
  this.x60_1 = new XDigestServiceAdapter(this.v60_1.z5k());
  this.y60_1 = new XRsaServiceAdapter(this.v60_1.x5k());
  this.z60_1 = new XStrongRandomAdapter(this.v60_1.y5k());
  this.a61_1 = new XHmacServiceAdapter(this.v60_1.a5l());
}
protoOf(XServiceAdapter).w5k = function () {
  return this.w60_1;
};
protoOf(XServiceAdapter).z5k = function () {
  return this.x60_1;
};
protoOf(XServiceAdapter).x5k = function () {
  return this.y60_1;
};
protoOf(XServiceAdapter).y5k = function () {
  return this.z60_1;
};
protoOf(XServiceAdapter).a5l = function () {
  return this.a61_1;
};
function ServiceAdapter(service) {
  this.b61_1 = service;
  this.c61_1 = new AesServiceAdapter(this.b61_1.aes);
  this.d61_1 = new DigestServiceAdapter(this.b61_1.digest);
  this.e61_1 = new RsaServiceAdapter(this.b61_1.rsa);
  this.f61_1 = new StrongRandomAdapter(this.b61_1.strongRandom);
  this.g61_1 = new HmacServiceAdapter(this.b61_1.hmac);
}
protoOf(ServiceAdapter).w5k = function () {
  return this.c61_1;
};
protoOf(ServiceAdapter).z5k = function () {
  return this.d61_1;
};
protoOf(ServiceAdapter).x5k = function () {
  return this.e61_1;
};
protoOf(ServiceAdapter).y5k = function () {
  return this.f61_1;
};
protoOf(ServiceAdapter).a5l = function () {
  return this.g61_1;
};
function XAesServiceAdapter$generateKey$slambda(this$0, $algorithm, $size, resultContinuation) {
  this.p61_1 = this$0;
  this.q61_1 = $algorithm;
  this.r61_1 = $size;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XAesServiceAdapter$generateKey$slambda).t61 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XAesServiceAdapter$generateKey$slambda).x9 = function (p1, $completion) {
  return this.t61((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XAesServiceAdapter$generateKey$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          var tmp_0 = Companion_instance.b5m(this.q61_1);
          var tmp$ret$0;
          l$ret$1: do {
            var tmp0_iterator = get_entries().p();
            while (tmp0_iterator.q()) {
              var element = tmp0_iterator.r();
              if (element.o5k_1 === this.r61_1) {
                tmp$ret$0 = element;
                break l$ret$1;
              }
            }
            throw NoSuchElementException_init_$Create$('Collection contains no element matching the predicate.');
          }
           while (false);
          suspendResult = this.p61_1.u61_1.p5k(tmp_0, tmp$ret$0, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toExternal(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XAesServiceAdapter$generateKey$slambda).l1r = function ($this$promise, completion) {
  var i = new XAesServiceAdapter$generateKey$slambda(this.p61_1, this.q61_1, this.r61_1, completion);
  i.s61_1 = $this$promise;
  return i;
};
function XAesServiceAdapter$generateKey$slambda_0(this$0, $algorithm, $size, resultContinuation) {
  var i = new XAesServiceAdapter$generateKey$slambda(this$0, $algorithm, $size, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.t61($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XAesServiceAdapter$exportKey$slambda(this$0, $key, resultContinuation) {
  this.d62_1 = this$0;
  this.e62_1 = $key;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XAesServiceAdapter$exportKey$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XAesServiceAdapter$exportKey$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XAesServiceAdapter$exportKey$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.d62_1.u61_1.r5k(toKryptom(this.e62_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XAesServiceAdapter$exportKey$slambda).l1r = function ($this$promise, completion) {
  var i = new XAesServiceAdapter$exportKey$slambda(this.d62_1, this.e62_1, completion);
  i.f62_1 = $this$promise;
  return i;
};
function XAesServiceAdapter$exportKey$slambda_0(this$0, $key, resultContinuation) {
  var i = new XAesServiceAdapter$exportKey$slambda(this$0, $key, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XAesServiceAdapter$loadKey$slambda(this$0, $algorithm, $bytes, resultContinuation) {
  this.p62_1 = this$0;
  this.q62_1 = $algorithm;
  this.r62_1 = $bytes;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XAesServiceAdapter$loadKey$slambda).t61 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XAesServiceAdapter$loadKey$slambda).x9 = function (p1, $completion) {
  return this.t61((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XAesServiceAdapter$loadKey$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.p62_1.u61_1.s5k(Companion_instance.b5m(this.q62_1), this.r62_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toExternal(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XAesServiceAdapter$loadKey$slambda).l1r = function ($this$promise, completion) {
  var i = new XAesServiceAdapter$loadKey$slambda(this.p62_1, this.q62_1, this.r62_1, completion);
  i.s62_1 = $this$promise;
  return i;
};
function XAesServiceAdapter$loadKey$slambda_0(this$0, $algorithm, $bytes, resultContinuation) {
  var i = new XAesServiceAdapter$loadKey$slambda(this$0, $algorithm, $bytes, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.t61($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XAesServiceAdapter$encrypt$slambda(this$0, $data, $key, $iv, resultContinuation) {
  this.b63_1 = this$0;
  this.c63_1 = $data;
  this.d63_1 = $key;
  this.e63_1 = $iv;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XAesServiceAdapter$encrypt$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XAesServiceAdapter$encrypt$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XAesServiceAdapter$encrypt$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.b63_1.u61_1.t5k(this.c63_1, toKryptom(this.d63_1), this.e63_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XAesServiceAdapter$encrypt$slambda).l1r = function ($this$promise, completion) {
  var i = new XAesServiceAdapter$encrypt$slambda(this.b63_1, this.c63_1, this.d63_1, this.e63_1, completion);
  i.f63_1 = $this$promise;
  return i;
};
function XAesServiceAdapter$encrypt$slambda_0(this$0, $data, $key, $iv, resultContinuation) {
  var i = new XAesServiceAdapter$encrypt$slambda(this$0, $data, $key, $iv, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XAesServiceAdapter$decrypt$slambda(this$0, $ivAndEncryptedData, $key, resultContinuation) {
  this.o63_1 = this$0;
  this.p63_1 = $ivAndEncryptedData;
  this.q63_1 = $key;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XAesServiceAdapter$decrypt$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XAesServiceAdapter$decrypt$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XAesServiceAdapter$decrypt$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.o63_1.u61_1.v5k(this.p63_1, toKryptom(this.q63_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XAesServiceAdapter$decrypt$slambda).l1r = function ($this$promise, completion) {
  var i = new XAesServiceAdapter$decrypt$slambda(this.o63_1, this.p63_1, this.q63_1, completion);
  i.r63_1 = $this$promise;
  return i;
};
function XAesServiceAdapter$decrypt$slambda_0(this$0, $ivAndEncryptedData, $key, resultContinuation) {
  var i = new XAesServiceAdapter$decrypt$slambda(this$0, $ivAndEncryptedData, $key, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XAesServiceAdapter(service) {
  this.u61_1 = service;
}
protoOf(XAesServiceAdapter).s63 = function (algorithm, size) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XAesServiceAdapter$generateKey$slambda_0(this, algorithm, size, null));
};
protoOf(XAesServiceAdapter).generateKey = function (algorithm, size) {
  return this.s63(algorithm, size);
};
protoOf(XAesServiceAdapter).t63 = function (key) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XAesServiceAdapter$exportKey$slambda_0(this, key, null));
};
protoOf(XAesServiceAdapter).exportKey = function (key) {
  return this.t63(key);
};
protoOf(XAesServiceAdapter).u63 = function (algorithm, bytes) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XAesServiceAdapter$loadKey$slambda_0(this, algorithm, bytes, null));
};
protoOf(XAesServiceAdapter).loadKey = function (algorithm, bytes) {
  return this.u63(algorithm, bytes);
};
protoOf(XAesServiceAdapter).v63 = function (data, key, iv) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XAesServiceAdapter$encrypt$slambda_0(this, data, key, iv, null));
};
protoOf(XAesServiceAdapter).encrypt = function (data, key, iv) {
  return this.v63(data, key, iv);
};
protoOf(XAesServiceAdapter).w63 = function (ivAndEncryptedData, key) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XAesServiceAdapter$decrypt$slambda_0(this, ivAndEncryptedData, key, null));
};
protoOf(XAesServiceAdapter).decrypt = function (ivAndEncryptedData, key) {
  return this.w63(ivAndEncryptedData, key);
};
function XDigestServiceAdapter$sha256$slambda(this$0, $data, resultContinuation) {
  this.f64_1 = this$0;
  this.g64_1 = $data;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XDigestServiceAdapter$sha256$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XDigestServiceAdapter$sha256$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XDigestServiceAdapter$sha256$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.f64_1.i64_1.y5s(this.g64_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XDigestServiceAdapter$sha256$slambda).l1r = function ($this$promise, completion) {
  var i = new XDigestServiceAdapter$sha256$slambda(this.f64_1, this.g64_1, completion);
  i.h64_1 = $this$promise;
  return i;
};
function XDigestServiceAdapter$sha256$slambda_0(this$0, $data, resultContinuation) {
  var i = new XDigestServiceAdapter$sha256$slambda(this$0, $data, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XDigestServiceAdapter$sha512$slambda(this$0, $data, resultContinuation) {
  this.r64_1 = this$0;
  this.s64_1 = $data;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XDigestServiceAdapter$sha512$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XDigestServiceAdapter$sha512$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XDigestServiceAdapter$sha512$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.r64_1.i64_1.z5s(this.s64_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XDigestServiceAdapter$sha512$slambda).l1r = function ($this$promise, completion) {
  var i = new XDigestServiceAdapter$sha512$slambda(this.r64_1, this.s64_1, completion);
  i.t64_1 = $this$promise;
  return i;
};
function XDigestServiceAdapter$sha512$slambda_0(this$0, $data, resultContinuation) {
  var i = new XDigestServiceAdapter$sha512$slambda(this$0, $data, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XDigestServiceAdapter(service) {
  this.i64_1 = service;
}
protoOf(XDigestServiceAdapter).u64 = function (data) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XDigestServiceAdapter$sha256$slambda_0(this, data, null));
};
protoOf(XDigestServiceAdapter).sha256 = function (data) {
  return this.u64(data);
};
protoOf(XDigestServiceAdapter).v64 = function (data) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XDigestServiceAdapter$sha512$slambda_0(this, data, null));
};
protoOf(XDigestServiceAdapter).sha512 = function (data) {
  return this.v64(data);
};
function XRsaServiceAdapter$generateKeyPair$slambda(this$0, $algorithm, $keySize, resultContinuation) {
  this.e65_1 = this$0;
  this.f65_1 = $algorithm;
  this.g65_1 = $keySize;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$generateKeyPair$slambda).i65 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$generateKeyPair$slambda).x9 = function (p1, $completion) {
  return this.i65((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$generateKeyPair$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          var tmp_0 = Companion_instance_3.b5m(this.f65_1);
          var tmp$ret$0;
          l$ret$1: do {
            var tmp0_iterator = get_entries_0().p();
            while (tmp0_iterator.q()) {
              var element = tmp0_iterator.r();
              if (element.d5n_1 === this.g65_1) {
                tmp$ret$0 = element;
                break l$ret$1;
              }
            }
            throw NoSuchElementException_init_$Create$('Collection contains no element matching the predicate.');
          }
           while (false);
          suspendResult = this.e65_1.j65_1.g5o(tmp_0, tmp$ret$0, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toExternal_1(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$generateKeyPair$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$generateKeyPair$slambda(this.e65_1, this.f65_1, this.g65_1, completion);
  i.h65_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$generateKeyPair$slambda_0(this$0, $algorithm, $keySize, resultContinuation) {
  var i = new XRsaServiceAdapter$generateKeyPair$slambda(this$0, $algorithm, $keySize, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.i65($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$exportPrivateKeyPkcs8$slambda(this$0, $key, resultContinuation) {
  this.s65_1 = this$0;
  this.t65_1 = $key;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$exportPrivateKeyPkcs8$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$exportPrivateKeyPkcs8$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$exportPrivateKeyPkcs8$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.s65_1.j65_1.q5n(toKryptom_4(this.t65_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$exportPrivateKeyPkcs8$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$exportPrivateKeyPkcs8$slambda(this.s65_1, this.t65_1, completion);
  i.u65_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$exportPrivateKeyPkcs8$slambda_0(this$0, $key, resultContinuation) {
  var i = new XRsaServiceAdapter$exportPrivateKeyPkcs8$slambda(this$0, $key, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$exportPublicKeySpki$slambda(this$0, $key, resultContinuation) {
  this.d66_1 = this$0;
  this.e66_1 = $key;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$exportPublicKeySpki$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$exportPublicKeySpki$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$exportPublicKeySpki$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.d66_1.j65_1.e5o(toKryptom_5(this.e66_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$exportPublicKeySpki$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$exportPublicKeySpki$slambda(this.d66_1, this.e66_1, completion);
  i.f66_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$exportPublicKeySpki$slambda_0(this$0, $key, resultContinuation) {
  var i = new XRsaServiceAdapter$exportPublicKeySpki$slambda(this$0, $key, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$loadKeyPairPkcs8$slambda(this$0, $algorithm, $privateKeyPkcs8, resultContinuation) {
  this.o66_1 = this$0;
  this.p66_1 = $algorithm;
  this.q66_1 = $privateKeyPkcs8;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$loadKeyPairPkcs8$slambda).i65 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$loadKeyPairPkcs8$slambda).x9 = function (p1, $completion) {
  return this.i65((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$loadKeyPairPkcs8$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.o66_1.j65_1.j5o(Companion_instance_3.b5m(this.p66_1), this.q66_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toExternal_1(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$loadKeyPairPkcs8$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$loadKeyPairPkcs8$slambda(this.o66_1, this.p66_1, this.q66_1, completion);
  i.r66_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$loadKeyPairPkcs8$slambda_0(this$0, $algorithm, $privateKeyPkcs8, resultContinuation) {
  var i = new XRsaServiceAdapter$loadKeyPairPkcs8$slambda(this$0, $algorithm, $privateKeyPkcs8, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.i65($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$loadPrivateKeyPkcs8$slambda(this$0, $algorithm, $privateKeyPkcs8, resultContinuation) {
  this.a67_1 = this$0;
  this.b67_1 = $algorithm;
  this.c67_1 = $privateKeyPkcs8;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$loadPrivateKeyPkcs8$slambda).e67 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$loadPrivateKeyPkcs8$slambda).x9 = function (p1, $completion) {
  return this.e67((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$loadPrivateKeyPkcs8$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.a67_1.j65_1.k5o(Companion_instance_3.b5m(this.b67_1), this.c67_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toExternal_2(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$loadPrivateKeyPkcs8$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$loadPrivateKeyPkcs8$slambda(this.a67_1, this.b67_1, this.c67_1, completion);
  i.d67_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$loadPrivateKeyPkcs8$slambda_0(this$0, $algorithm, $privateKeyPkcs8, resultContinuation) {
  var i = new XRsaServiceAdapter$loadPrivateKeyPkcs8$slambda(this$0, $algorithm, $privateKeyPkcs8, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.e67($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$loadPublicKeySpki$slambda(this$0, $algorithm, $publicKeySpki, resultContinuation) {
  this.n67_1 = this$0;
  this.o67_1 = $algorithm;
  this.p67_1 = $publicKeySpki;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$loadPublicKeySpki$slambda).r67 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$loadPublicKeySpki$slambda).x9 = function (p1, $completion) {
  return this.r67((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$loadPublicKeySpki$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.n67_1.j65_1.n5o(Companion_instance_3.b5m(this.o67_1), this.p67_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toExternal_3(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$loadPublicKeySpki$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$loadPublicKeySpki$slambda(this.n67_1, this.o67_1, this.p67_1, completion);
  i.q67_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$loadPublicKeySpki$slambda_0(this$0, $algorithm, $publicKeySpki, resultContinuation) {
  var i = new XRsaServiceAdapter$loadPublicKeySpki$slambda(this$0, $algorithm, $publicKeySpki, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.r67($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$encrypt$slambda(this$0, $data, $publicKey, resultContinuation) {
  this.a68_1 = this$0;
  this.b68_1 = $data;
  this.c68_1 = $publicKey;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$encrypt$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$encrypt$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$encrypt$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.a68_1.j65_1.q5o(this.b68_1, toKryptomEncryption_0(this.c68_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$encrypt$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$encrypt$slambda(this.a68_1, this.b68_1, this.c68_1, completion);
  i.d68_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$encrypt$slambda_0(this$0, $data, $publicKey, resultContinuation) {
  var i = new XRsaServiceAdapter$encrypt$slambda(this$0, $data, $publicKey, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$decrypt$slambda(this$0, $data, $privateKey, resultContinuation) {
  this.m68_1 = this$0;
  this.n68_1 = $data;
  this.o68_1 = $privateKey;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$decrypt$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$decrypt$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$decrypt$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.m68_1.j65_1.r5o(this.n68_1, toKryptomEncryption(this.o68_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$decrypt$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$decrypt$slambda(this.m68_1, this.n68_1, this.o68_1, completion);
  i.p68_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$decrypt$slambda_0(this$0, $data, $privateKey, resultContinuation) {
  var i = new XRsaServiceAdapter$decrypt$slambda(this$0, $data, $privateKey, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$sign$slambda(this$0, $data, $privateKey, resultContinuation) {
  this.y68_1 = this$0;
  this.z68_1 = $data;
  this.a69_1 = $privateKey;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$sign$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$sign$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$sign$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.y68_1.j65_1.s5o(this.z68_1, toKryptomSignature(this.a69_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$sign$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$sign$slambda(this.y68_1, this.z68_1, this.a69_1, completion);
  i.b69_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$sign$slambda_0(this$0, $data, $privateKey, resultContinuation) {
  var i = new XRsaServiceAdapter$sign$slambda(this$0, $data, $privateKey, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$verifySignature$slambda(this$0, $signature, $data, $publicKey, resultContinuation) {
  this.k69_1 = this$0;
  this.l69_1 = $signature;
  this.m69_1 = $data;
  this.n69_1 = $publicKey;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$verifySignature$slambda).p69 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$verifySignature$slambda).x9 = function (p1, $completion) {
  return this.p69((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$verifySignature$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.k69_1.j65_1.t5o(this.l69_1, this.m69_1, toKryptomSignature_0(this.n69_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$verifySignature$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$verifySignature$slambda(this.k69_1, this.l69_1, this.m69_1, this.n69_1, completion);
  i.o69_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$verifySignature$slambda_0(this$0, $signature, $data, $publicKey, resultContinuation) {
  var i = new XRsaServiceAdapter$verifySignature$slambda(this$0, $signature, $data, $publicKey, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.p69($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$exportPrivateKeyJwk$slambda(this$0, $key, resultContinuation) {
  this.y69_1 = this$0;
  this.z69_1 = $key;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$exportPrivateKeyJwk$slambda).b6a = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$exportPrivateKeyJwk$slambda).x9 = function (p1, $completion) {
  return this.b6a((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$exportPrivateKeyJwk$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.y69_1.j65_1.h5o(toKryptom_4(this.z69_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toPrivateJwk(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$exportPrivateKeyJwk$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$exportPrivateKeyJwk$slambda(this.y69_1, this.z69_1, completion);
  i.a6a_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$exportPrivateKeyJwk$slambda_0(this$0, $key, resultContinuation) {
  var i = new XRsaServiceAdapter$exportPrivateKeyJwk$slambda(this$0, $key, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.b6a($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$exportPublicKeyJwk$slambda(this$0, $key, resultContinuation) {
  this.k6a_1 = this$0;
  this.l6a_1 = $key;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$exportPublicKeyJwk$slambda).b6a = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$exportPublicKeyJwk$slambda).x9 = function (p1, $completion) {
  return this.b6a((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$exportPublicKeyJwk$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.k6a_1.j65_1.i5o(toKryptom_5(this.l6a_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toPublicJwk(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$exportPublicKeyJwk$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$exportPublicKeyJwk$slambda(this.k6a_1, this.l6a_1, completion);
  i.m6a_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$exportPublicKeyJwk$slambda_0(this$0, $key, resultContinuation) {
  var i = new XRsaServiceAdapter$exportPublicKeyJwk$slambda(this$0, $key, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.b6a($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$loadPrivateKeyJwk$slambda($privateKeyJwk, this$0, resultContinuation) {
  this.v6a_1 = $privateKeyJwk;
  this.w6a_1 = this$0;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$loadPrivateKeyJwk$slambda).e67 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$loadPrivateKeyJwk$slambda).x9 = function (p1, $completion) {
  return this.e67((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$loadPrivateKeyJwk$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.y6a_1 = toPrivateJwk_0(this.v6a_1);
          this.f9_1 = 1;
          suspendResult = this.w6a_1.j65_1.l5o(Companion_instance_3.t5m(this.y6a_1.h5l_1), this.y6a_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toExternal_2(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$loadPrivateKeyJwk$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$loadPrivateKeyJwk$slambda(this.v6a_1, this.w6a_1, completion);
  i.x6a_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$loadPrivateKeyJwk$slambda_0($privateKeyJwk, this$0, resultContinuation) {
  var i = new XRsaServiceAdapter$loadPrivateKeyJwk$slambda($privateKeyJwk, this$0, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.e67($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter$loadPublicKeyJwk$slambda($publicKeyJwk, this$0, resultContinuation) {
  this.h6b_1 = $publicKeyJwk;
  this.i6b_1 = this$0;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XRsaServiceAdapter$loadPublicKeyJwk$slambda).r67 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XRsaServiceAdapter$loadPublicKeyJwk$slambda).x9 = function (p1, $completion) {
  return this.r67((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XRsaServiceAdapter$loadPublicKeyJwk$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.k6b_1 = toPublicJwk_0(this.h6b_1);
          this.f9_1 = 1;
          suspendResult = this.i6b_1.j65_1.o5o(Companion_instance_3.t5m(this.k6b_1.t5l_1), this.k6b_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toExternal_3(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XRsaServiceAdapter$loadPublicKeyJwk$slambda).l1r = function ($this$promise, completion) {
  var i = new XRsaServiceAdapter$loadPublicKeyJwk$slambda(this.h6b_1, this.i6b_1, completion);
  i.j6b_1 = $this$promise;
  return i;
};
function XRsaServiceAdapter$loadPublicKeyJwk$slambda_0($publicKeyJwk, this$0, resultContinuation) {
  var i = new XRsaServiceAdapter$loadPublicKeyJwk$slambda($publicKeyJwk, this$0, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.r67($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XRsaServiceAdapter(service) {
  this.j65_1 = service;
}
protoOf(XRsaServiceAdapter).l6b = function (algorithm, keySize) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$generateKeyPair$slambda_0(this, algorithm, keySize, null));
};
protoOf(XRsaServiceAdapter).generateKeyPair = function (algorithm, keySize) {
  return this.l6b(algorithm, keySize);
};
protoOf(XRsaServiceAdapter).m6b = function (key) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$exportPrivateKeyPkcs8$slambda_0(this, key, null));
};
protoOf(XRsaServiceAdapter).exportPrivateKeyPkcs8 = function (key) {
  return this.m6b(key);
};
protoOf(XRsaServiceAdapter).n6b = function (key) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$exportPublicKeySpki$slambda_0(this, key, null));
};
protoOf(XRsaServiceAdapter).exportPublicKeySpki = function (key) {
  return this.n6b(key);
};
protoOf(XRsaServiceAdapter).o6b = function (algorithm, privateKeyPkcs8) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$loadKeyPairPkcs8$slambda_0(this, algorithm, privateKeyPkcs8, null));
};
protoOf(XRsaServiceAdapter).loadKeyPairPkcs8 = function (algorithm, privateKeyPkcs8) {
  return this.o6b(algorithm, privateKeyPkcs8);
};
protoOf(XRsaServiceAdapter).p6b = function (algorithm, privateKeyPkcs8) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$loadPrivateKeyPkcs8$slambda_0(this, algorithm, privateKeyPkcs8, null));
};
protoOf(XRsaServiceAdapter).loadPrivateKeyPkcs8 = function (algorithm, privateKeyPkcs8) {
  return this.p6b(algorithm, privateKeyPkcs8);
};
protoOf(XRsaServiceAdapter).q6b = function (algorithm, publicKeySpki) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$loadPublicKeySpki$slambda_0(this, algorithm, publicKeySpki, null));
};
protoOf(XRsaServiceAdapter).loadPublicKeySpki = function (algorithm, publicKeySpki) {
  return this.q6b(algorithm, publicKeySpki);
};
protoOf(XRsaServiceAdapter).r6b = function (data, publicKey) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$encrypt$slambda_0(this, data, publicKey, null));
};
protoOf(XRsaServiceAdapter).encrypt = function (data, publicKey) {
  return this.r6b(data, publicKey);
};
protoOf(XRsaServiceAdapter).s6b = function (data, privateKey) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$decrypt$slambda_0(this, data, privateKey, null));
};
protoOf(XRsaServiceAdapter).decrypt = function (data, privateKey) {
  return this.s6b(data, privateKey);
};
protoOf(XRsaServiceAdapter).t6b = function (data, privateKey) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$sign$slambda_0(this, data, privateKey, null));
};
protoOf(XRsaServiceAdapter).sign = function (data, privateKey) {
  return this.t6b(data, privateKey);
};
protoOf(XRsaServiceAdapter).u6b = function (signature, data, publicKey) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$verifySignature$slambda_0(this, signature, data, publicKey, null));
};
protoOf(XRsaServiceAdapter).verifySignature = function (signature, data, publicKey) {
  return this.u6b(signature, data, publicKey);
};
protoOf(XRsaServiceAdapter).v6b = function (key) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$exportPrivateKeyJwk$slambda_0(this, key, null));
};
protoOf(XRsaServiceAdapter).exportPrivateKeyJwk = function (key) {
  return this.v6b(key);
};
protoOf(XRsaServiceAdapter).w6b = function (key) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$exportPublicKeyJwk$slambda_0(this, key, null));
};
protoOf(XRsaServiceAdapter).exportPublicKeyJwk = function (key) {
  return this.w6b(key);
};
protoOf(XRsaServiceAdapter).x6b = function (privateKeyJwk) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$loadPrivateKeyJwk$slambda_0(privateKeyJwk, this, null));
};
protoOf(XRsaServiceAdapter).loadPrivateKeyJwk = function (privateKeyJwk) {
  return this.x6b(privateKeyJwk);
};
protoOf(XRsaServiceAdapter).y6b = function (publicKeyJwk) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XRsaServiceAdapter$loadPublicKeyJwk$slambda_0(publicKeyJwk, this, null));
};
protoOf(XRsaServiceAdapter).loadPublicKeyJwk = function (publicKeyJwk) {
  return this.y6b(publicKeyJwk);
};
function XStrongRandomAdapter(service) {
  this.z6b_1 = service;
}
protoOf(XStrongRandomAdapter).u5o = function (length) {
  return this.z6b_1.u5o(length);
};
protoOf(XStrongRandomAdapter).randomBytes = function (length) {
  return this.u5o(length);
};
protoOf(XStrongRandomAdapter).w5o = function () {
  return this.z6b_1.w5o();
};
protoOf(XStrongRandomAdapter).randomUUID = function () {
  return this.w5o();
};
function XHmacServiceAdapter$generateKey$slambda(this$0, $algorithm, $keySize, resultContinuation) {
  this.i6c_1 = this$0;
  this.j6c_1 = $algorithm;
  this.k6c_1 = $keySize;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XHmacServiceAdapter$generateKey$slambda).m6c = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XHmacServiceAdapter$generateKey$slambda).x9 = function (p1, $completion) {
  return this.m6c((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XHmacServiceAdapter$generateKey$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.i6c_1.n6c_1.b5l(Companion_instance_0.b5m(this.j6c_1), this.k6c_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toExternal_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XHmacServiceAdapter$generateKey$slambda).l1r = function ($this$promise, completion) {
  var i = new XHmacServiceAdapter$generateKey$slambda(this.i6c_1, this.j6c_1, this.k6c_1, completion);
  i.l6c_1 = $this$promise;
  return i;
};
function XHmacServiceAdapter$generateKey$slambda_0(this$0, $algorithm, $keySize, resultContinuation) {
  var i = new XHmacServiceAdapter$generateKey$slambda(this$0, $algorithm, $keySize, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.m6c($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XHmacServiceAdapter$exportKey$slambda(this$0, $key, resultContinuation) {
  this.w6c_1 = this$0;
  this.x6c_1 = $key;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XHmacServiceAdapter$exportKey$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XHmacServiceAdapter$exportKey$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XHmacServiceAdapter$exportKey$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.w6c_1.n6c_1.d5l(toKryptom_1(this.x6c_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XHmacServiceAdapter$exportKey$slambda).l1r = function ($this$promise, completion) {
  var i = new XHmacServiceAdapter$exportKey$slambda(this.w6c_1, this.x6c_1, completion);
  i.y6c_1 = $this$promise;
  return i;
};
function XHmacServiceAdapter$exportKey$slambda_0(this$0, $key, resultContinuation) {
  var i = new XHmacServiceAdapter$exportKey$slambda(this$0, $key, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XHmacServiceAdapter$loadKey$slambda(this$0, $algorithm, $bytes, resultContinuation) {
  this.h6d_1 = this$0;
  this.i6d_1 = $algorithm;
  this.j6d_1 = $bytes;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XHmacServiceAdapter$loadKey$slambda).m6c = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XHmacServiceAdapter$loadKey$slambda).x9 = function (p1, $completion) {
  return this.m6c((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XHmacServiceAdapter$loadKey$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.h6d_1.n6c_1.e5l(Companion_instance_0.b5m(this.i6d_1), this.j6d_1, this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toExternal_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XHmacServiceAdapter$loadKey$slambda).l1r = function ($this$promise, completion) {
  var i = new XHmacServiceAdapter$loadKey$slambda(this.h6d_1, this.i6d_1, this.j6d_1, completion);
  i.k6d_1 = $this$promise;
  return i;
};
function XHmacServiceAdapter$loadKey$slambda_0(this$0, $algorithm, $bytes, resultContinuation) {
  var i = new XHmacServiceAdapter$loadKey$slambda(this$0, $algorithm, $bytes, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.m6c($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XHmacServiceAdapter$sign$slambda(this$0, $data, $key, resultContinuation) {
  this.t6d_1 = this$0;
  this.u6d_1 = $data;
  this.v6d_1 = $key;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XHmacServiceAdapter$sign$slambda).g62 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XHmacServiceAdapter$sign$slambda).x9 = function (p1, $completion) {
  return this.g62((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XHmacServiceAdapter$sign$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.t6d_1.n6c_1.f5l(this.u6d_1, toKryptom_1(this.v6d_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XHmacServiceAdapter$sign$slambda).l1r = function ($this$promise, completion) {
  var i = new XHmacServiceAdapter$sign$slambda(this.t6d_1, this.u6d_1, this.v6d_1, completion);
  i.w6d_1 = $this$promise;
  return i;
};
function XHmacServiceAdapter$sign$slambda_0(this$0, $data, $key, resultContinuation) {
  var i = new XHmacServiceAdapter$sign$slambda(this$0, $data, $key, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.g62($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XHmacServiceAdapter$verify$slambda(this$0, $signature, $data, $key, resultContinuation) {
  this.f6e_1 = this$0;
  this.g6e_1 = $signature;
  this.h6e_1 = $data;
  this.i6e_1 = $key;
  CoroutineImpl.call(this, resultContinuation);
}
protoOf(XHmacServiceAdapter$verify$slambda).p69 = function ($this$promise, $completion) {
  var tmp = this.l1r($this$promise, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(XHmacServiceAdapter$verify$slambda).x9 = function (p1, $completion) {
  return this.p69((!(p1 == null) ? isInterface(p1, CoroutineScope) : false) ? p1 : THROW_CCE(), $completion);
};
protoOf(XHmacServiceAdapter$verify$slambda).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = this.f6e_1.n6c_1.g5l(this.g6e_1, this.h6e_1, toKryptom_1(this.i6e_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          return suspendResult;
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
protoOf(XHmacServiceAdapter$verify$slambda).l1r = function ($this$promise, completion) {
  var i = new XHmacServiceAdapter$verify$slambda(this.f6e_1, this.g6e_1, this.h6e_1, this.i6e_1, completion);
  i.j6e_1 = $this$promise;
  return i;
};
function XHmacServiceAdapter$verify$slambda_0(this$0, $signature, $data, $key, resultContinuation) {
  var i = new XHmacServiceAdapter$verify$slambda(this$0, $signature, $data, $key, resultContinuation);
  var l = function ($this$promise, $completion) {
    return i.p69($this$promise, $completion);
  };
  l.$arity = 1;
  return l;
}
function XHmacServiceAdapter(service) {
  this.n6c_1 = service;
}
protoOf(XHmacServiceAdapter).k6e = function (algorithm, keySize) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XHmacServiceAdapter$generateKey$slambda_0(this, algorithm, keySize, null));
};
protoOf(XHmacServiceAdapter).generateKey = function (algorithm, keySize) {
  return this.k6e(algorithm, keySize);
};
protoOf(XHmacServiceAdapter).l6e = function (key) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XHmacServiceAdapter$exportKey$slambda_0(this, key, null));
};
protoOf(XHmacServiceAdapter).exportKey = function (key) {
  return this.l6e(key);
};
protoOf(XHmacServiceAdapter).u63 = function (algorithm, bytes) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XHmacServiceAdapter$loadKey$slambda_0(this, algorithm, bytes, null));
};
protoOf(XHmacServiceAdapter).loadKey = function (algorithm, bytes) {
  return this.u63(algorithm, bytes);
};
protoOf(XHmacServiceAdapter).m6e = function (data, key) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XHmacServiceAdapter$sign$slambda_0(this, data, key, null));
};
protoOf(XHmacServiceAdapter).sign = function (data, key) {
  return this.m6e(data, key);
};
protoOf(XHmacServiceAdapter).n6e = function (signature, data, key) {
  var tmp = GlobalScope_instance;
  return promise(tmp, VOID, VOID, XHmacServiceAdapter$verify$slambda_0(this, signature, data, key, null));
};
protoOf(XHmacServiceAdapter).verify = function (signature, data, key) {
  return this.n6e(signature, data, key);
};
function $generateKeyCOROUTINE$27(_this__u8e3s4, algorithm, size, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.w6e_1 = _this__u8e3s4;
  this.x6e_1 = algorithm;
  this.y6e_1 = size;
}
protoOf($generateKeyCOROUTINE$27).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.w6e_1.z6e_1.generateKey(this.x6e_1.a5m(), this.y6e_1.o5k_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toKryptom_0(ARGUMENT, this.x6e_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadKeyCOROUTINE$28(_this__u8e3s4, algorithm, bytes, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.i6f_1 = _this__u8e3s4;
  this.j6f_1 = algorithm;
  this.k6f_1 = bytes;
}
protoOf($loadKeyCOROUTINE$28).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.i6f_1.z6e_1.loadKey(this.j6f_1.a5m(), this.k6f_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toKryptom_0(ARGUMENT, this.j6f_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function AesServiceAdapter(service) {
  this.z6e_1 = service;
}
protoOf(AesServiceAdapter).p5k = function (algorithm, size, $completion) {
  var tmp = new $generateKeyCOROUTINE$27(this, algorithm, size, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(AesServiceAdapter).r5k = function (key, $completion) {
  return await_0(this.z6e_1.exportKey(toExternal(key)), $completion);
};
protoOf(AesServiceAdapter).s5k = function (algorithm, bytes, $completion) {
  var tmp = new $loadKeyCOROUTINE$28(this, algorithm, bytes, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(AesServiceAdapter).t5k = function (data, key, iv, $completion) {
  return await_0(this.z6e_1.encrypt(data, toExternal(key), iv), $completion);
};
protoOf(AesServiceAdapter).v5k = function (ivAndEncryptedData, key, $completion) {
  return await_0(this.z6e_1.decrypt(ivAndEncryptedData, toExternal(key)), $completion);
};
function DigestServiceAdapter(service) {
  this.l6f_1 = service;
}
protoOf(DigestServiceAdapter).y5s = function (data, $completion) {
  return await_0(this.l6f_1.sha256(data), $completion);
};
protoOf(DigestServiceAdapter).z5s = function (data, $completion) {
  return await_0(this.l6f_1.sha512(data), $completion);
};
function $generateKeyPairCOROUTINE$29(_this__u8e3s4, algorithm, keySize, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.u6f_1 = _this__u8e3s4;
  this.v6f_1 = algorithm;
  this.w6f_1 = keySize;
}
protoOf($generateKeyPairCOROUTINE$29).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.u6f_1.x6f_1.generateKeyPair(this.v6f_1.a5m(), this.w6f_1.d5n_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toKryptom_3(ARGUMENT, this.v6f_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadPrivateKeyPkcs8COROUTINE$30(_this__u8e3s4, algorithm, privateKeyPkcs8, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.g6g_1 = _this__u8e3s4;
  this.h6g_1 = algorithm;
  this.i6g_1 = privateKeyPkcs8;
}
protoOf($loadPrivateKeyPkcs8COROUTINE$30).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.g6g_1.x6f_1.loadPrivateKeyPkcs8(this.h6g_1.a5m(), this.i6g_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toKryptom_6(ARGUMENT, this.h6g_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadKeyPairPkcs8COROUTINE$31(_this__u8e3s4, algorithm, privateKeyPkcs8, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.r6g_1 = _this__u8e3s4;
  this.s6g_1 = algorithm;
  this.t6g_1 = privateKeyPkcs8;
}
protoOf($loadKeyPairPkcs8COROUTINE$31).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.r6g_1.x6f_1.loadKeyPairPkcs8(this.s6g_1.a5m(), this.t6g_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toKryptom_3(ARGUMENT, this.s6g_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadPublicKeySpkiCOROUTINE$32(_this__u8e3s4, algorithm, publicKeySpki, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.c6h_1 = _this__u8e3s4;
  this.d6h_1 = algorithm;
  this.e6h_1 = publicKeySpki;
}
protoOf($loadPublicKeySpkiCOROUTINE$32).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.c6h_1.x6f_1.loadPublicKeySpki(this.d6h_1.a5m(), this.e6h_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toKryptom_7(ARGUMENT, this.d6h_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $exportPrivateKeyJwkCOROUTINE$33(_this__u8e3s4, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.n6h_1 = _this__u8e3s4;
  this.o6h_1 = key;
}
protoOf($exportPrivateKeyJwkCOROUTINE$33).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.n6h_1.x6f_1.exportPrivateKeyJwk(toExternal_2(this.o6h_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toPrivateJwk_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $exportPublicKeyJwkCOROUTINE$34(_this__u8e3s4, key, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.x6h_1 = _this__u8e3s4;
  this.y6h_1 = key;
}
protoOf($exportPublicKeyJwkCOROUTINE$34).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.x6h_1.x6f_1.exportPublicKeyJwk(toExternal_3(this.y6h_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toPublicJwk_0(ARGUMENT);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadPrivateKeyJwkCOROUTINE$35(_this__u8e3s4, algorithm, privateKeyJwk, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.h6i_1 = _this__u8e3s4;
  this.i6i_1 = algorithm;
  this.j6i_1 = privateKeyJwk;
}
protoOf($loadPrivateKeyJwkCOROUTINE$35).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.h6i_1.x6f_1.loadPrivateKeyJwk(toPrivateJwk(this.j6i_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toKryptom_6(ARGUMENT, this.i6i_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadPublicKeyJwkCOROUTINE$36(_this__u8e3s4, algorithm, publicKeyJwk, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.s6i_1 = _this__u8e3s4;
  this.t6i_1 = algorithm;
  this.u6i_1 = publicKeyJwk;
}
protoOf($loadPublicKeyJwkCOROUTINE$36).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.s6i_1.x6f_1.loadPublicKeyJwk(toPublicJwk(this.u6i_1)), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toKryptom_7(ARGUMENT, this.t6i_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function RsaServiceAdapter(service) {
  this.x6f_1 = service;
}
protoOf(RsaServiceAdapter).g5o = function (algorithm, keySize, $completion) {
  var tmp = new $generateKeyPairCOROUTINE$29(this, algorithm, keySize, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(RsaServiceAdapter).q5n = function (key, $completion) {
  return await_0(this.x6f_1.exportPrivateKeyPkcs8(toExternal_2(key)), $completion);
};
protoOf(RsaServiceAdapter).k5o = function (algorithm, privateKeyPkcs8, $completion) {
  var tmp = new $loadPrivateKeyPkcs8COROUTINE$30(this, algorithm, privateKeyPkcs8, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(RsaServiceAdapter).e5o = function (key, $completion) {
  return await_0(this.x6f_1.exportPublicKeySpki(toExternal_3(key)), $completion);
};
protoOf(RsaServiceAdapter).j5o = function (algorithm, privateKeyPkcs8, $completion) {
  var tmp = new $loadKeyPairPkcs8COROUTINE$31(this, algorithm, privateKeyPkcs8, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(RsaServiceAdapter).n5o = function (algorithm, publicKeySpki, $completion) {
  var tmp = new $loadPublicKeySpkiCOROUTINE$32(this, algorithm, publicKeySpki, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(RsaServiceAdapter).q5o = function (data, publicKey, $completion) {
  return await_0(this.x6f_1.encrypt(data, toExternal_3(publicKey)), $completion);
};
protoOf(RsaServiceAdapter).r5o = function (data, privateKey, $completion) {
  return await_0(this.x6f_1.decrypt(data, toExternal_2(privateKey)), $completion);
};
protoOf(RsaServiceAdapter).s5o = function (data, privateKey, $completion) {
  return await_0(this.x6f_1.sign(data, toExternal_2(privateKey)), $completion);
};
protoOf(RsaServiceAdapter).t5o = function (signature, data, publicKey, $completion) {
  return await_0(this.x6f_1.verifySignature(signature, data, toExternal_3(publicKey)), $completion);
};
protoOf(RsaServiceAdapter).h5o = function (key, $completion) {
  var tmp = new $exportPrivateKeyJwkCOROUTINE$33(this, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(RsaServiceAdapter).i5o = function (key, $completion) {
  var tmp = new $exportPublicKeyJwkCOROUTINE$34(this, key, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(RsaServiceAdapter).l5o = function (algorithm, privateKeyJwk, $completion) {
  var tmp = new $loadPrivateKeyJwkCOROUTINE$35(this, algorithm, privateKeyJwk, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(RsaServiceAdapter).o5o = function (algorithm, publicKeyJwk, $completion) {
  var tmp = new $loadPublicKeyJwkCOROUTINE$36(this, algorithm, publicKeyJwk, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
function StrongRandomAdapter(service) {
  this.v6i_1 = service;
}
protoOf(StrongRandomAdapter).v5o = function (array) {
  var random = this.v6i_1.randomBytes(array.length);
  // Inline function 'kotlin.collections.copyInto' call
  var endIndex = random.length;
  // Inline function 'kotlin.js.unsafeCast' call
  // Inline function 'kotlin.js.asDynamic' call
  var tmp = random;
  // Inline function 'kotlin.js.unsafeCast' call
  // Inline function 'kotlin.js.asDynamic' call
  arrayCopy(tmp, array, 0, 0, endIndex);
};
protoOf(StrongRandomAdapter).u5o = function (length) {
  return this.v6i_1.randomBytes(length);
};
protoOf(StrongRandomAdapter).w5o = function () {
  return this.v6i_1.randomUUID();
};
function $generateKeyCOROUTINE$37(_this__u8e3s4, algorithm, keySize, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.e6j_1 = _this__u8e3s4;
  this.f6j_1 = algorithm;
  this.g6j_1 = keySize;
}
protoOf($generateKeyCOROUTINE$37).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.e6j_1.h6j_1.generateKey(this.f6j_1.a5m(), this.g6j_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toKryptom_2(ARGUMENT, this.f6j_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function $loadKeyCOROUTINE$38(_this__u8e3s4, algorithm, bytes, resultContinuation) {
  CoroutineImpl.call(this, resultContinuation);
  this.q6j_1 = _this__u8e3s4;
  this.r6j_1 = algorithm;
  this.s6j_1 = bytes;
}
protoOf($loadKeyCOROUTINE$38).n9 = function () {
  var suspendResult = this.h9_1;
  $sm: do
    try {
      var tmp = this.f9_1;
      switch (tmp) {
        case 0:
          this.g9_1 = 2;
          this.f9_1 = 1;
          suspendResult = await_0(this.q6j_1.h6j_1.loadKey(this.r6j_1.a5m(), this.s6j_1), this);
          if (suspendResult === get_COROUTINE_SUSPENDED()) {
            return suspendResult;
          }

          continue $sm;
        case 1:
          var ARGUMENT = suspendResult;
          return toKryptom_2(ARGUMENT, this.r6j_1);
        case 2:
          throw this.i9_1;
      }
    } catch ($p) {
      var e = $p;
      if (this.g9_1 === 2) {
        throw e;
      } else {
        this.f9_1 = this.g9_1;
        this.i9_1 = e;
      }
    }
   while (true);
};
function HmacServiceAdapter(service) {
  this.h6j_1 = service;
}
protoOf(HmacServiceAdapter).b5l = function (algorithm, keySize, $completion) {
  var tmp = new $generateKeyCOROUTINE$37(this, algorithm, keySize, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(HmacServiceAdapter).d5l = function (key, $completion) {
  return await_0(this.h6j_1.exportKey(toExternal_0(key)), $completion);
};
protoOf(HmacServiceAdapter).e5l = function (algorithm, bytes, $completion) {
  var tmp = new $loadKeyCOROUTINE$38(this, algorithm, bytes, $completion);
  tmp.h9_1 = Unit_instance;
  tmp.i9_1 = null;
  return tmp.n9();
};
protoOf(HmacServiceAdapter).f5l = function (data, key, $completion) {
  return await_0(this.h6j_1.sign(data, toExternal_0(key)), $completion);
};
protoOf(HmacServiceAdapter).g5l = function (signature, data, key, $completion) {
  return await_0(this.h6j_1.verify(signature, data, toExternal_0(key)), $completion);
};
function toExternal_0(_this__u8e3s4) {
  var thisKey = _this__u8e3s4.h5u_1;
  var algorithmIdentifier = _this__u8e3s4.j5u_1.a5m();
  var tmp = {hmacKey: thisKey, algorithm: algorithmIdentifier};
  return (!(tmp == null) ? !(tmp == null) : false) ? tmp : THROW_CCE();
}
function toKryptom_1(_this__u8e3s4) {
  return new HmacKey(_this__u8e3s4.hmacKey, _this__u8e3s4.keySize, Companion_instance_0.b5m(_this__u8e3s4.algorithm));
}
function toKryptom_2(_this__u8e3s4, algorithm) {
  if (!(_this__u8e3s4.algorithm === algorithm.a5m())) {
    throw AssertionError_init_$Create$('Algorithm mismatch: ' + _this__u8e3s4.algorithm + ' != ' + algorithm.a5m());
  }
  return new HmacKey(_this__u8e3s4.hmacKey, _this__u8e3s4.keySize, algorithm);
}
function toExternal_1(_this__u8e3s4) {
  var private_0 = toExternal_2(_this__u8e3s4.u5m_1);
  var public_0 = toExternal_3(_this__u8e3s4.v5m_1);
  return {private: private_0, public: public_0};
}
function toKryptom_3(_this__u8e3s4, algorithm) {
  return new RsaKeypair(toKryptom_6(_this__u8e3s4.private, algorithm), toKryptom_7(_this__u8e3s4.public, algorithm));
}
function toKryptomEncryption(_this__u8e3s4) {
  return new PrivateRsaKey(_this__u8e3s4.privateKey, Companion_instance_1.b5m(_this__u8e3s4.algorithm));
}
function toKryptomEncryption_0(_this__u8e3s4) {
  return new PublicRsaKey(_this__u8e3s4.publicKey, Companion_instance_1.b5m(_this__u8e3s4.algorithm));
}
function toKryptom_4(_this__u8e3s4) {
  return new PrivateRsaKey(_this__u8e3s4.privateKey, Companion_instance_3.b5m(_this__u8e3s4.algorithm));
}
function toKryptom_5(_this__u8e3s4) {
  return new PublicRsaKey(_this__u8e3s4.publicKey, Companion_instance_3.b5m(_this__u8e3s4.algorithm));
}
function toExternal_2(_this__u8e3s4) {
  var algorithmIdentifier = _this__u8e3s4.x5m_1.a5m();
  var thisKey = _this__u8e3s4.w5m_1;
  var tmp = {privateKey: thisKey, algorithm: algorithmIdentifier};
  return (!(tmp == null) ? !(tmp == null) : false) ? tmp : THROW_CCE();
}
function toExternal_3(_this__u8e3s4) {
  var algorithmIdentifier = _this__u8e3s4.z5m_1.a5m();
  var thisKey = _this__u8e3s4.y5m_1;
  var tmp = {publicKey: thisKey, algorithm: algorithmIdentifier};
  return (!(tmp == null) ? !(tmp == null) : false) ? tmp : THROW_CCE();
}
function toKryptomSignature(_this__u8e3s4) {
  return new PrivateRsaKey(_this__u8e3s4.privateKey, Companion_instance_2.b5m(_this__u8e3s4.algorithm));
}
function toKryptomSignature_0(_this__u8e3s4) {
  return new PublicRsaKey(_this__u8e3s4.publicKey, Companion_instance_2.b5m(_this__u8e3s4.algorithm));
}
function toPrivateJwk(_this__u8e3s4) {
  var alg = _this__u8e3s4.h5l_1;
  var d = _this__u8e3s4.i5l_1;
  var dp = _this__u8e3s4.j5l_1;
  var dq = _this__u8e3s4.k5l_1;
  var e = _this__u8e3s4.l5l_1;
  var ext = _this__u8e3s4.m5l_1;
  // Inline function 'kotlin.collections.toTypedArray' call
  var this_0 = _this__u8e3s4.n5l_1;
  var key_ops = copyToArray(this_0);
  var n = _this__u8e3s4.o5l_1;
  var p = _this__u8e3s4.p5l_1;
  var q = _this__u8e3s4.q5l_1;
  var qi = _this__u8e3s4.r5l_1;
  var tmp = {alg: alg, d: d, dp: dp, dq: dq, e: e, ext: ext, key_ops: key_ops, n: n, p: p, q: q, qi: qi};
  return (!(tmp == null) ? !(tmp == null) : false) ? tmp : THROW_CCE();
}
function toPublicJwk(_this__u8e3s4) {
  var alg = _this__u8e3s4.t5l_1;
  var e = _this__u8e3s4.u5l_1;
  var ext = _this__u8e3s4.v5l_1;
  // Inline function 'kotlin.collections.toTypedArray' call
  var this_0 = _this__u8e3s4.w5l_1;
  var key_ops = copyToArray(this_0);
  var n = _this__u8e3s4.x5l_1;
  var tmp = {alg: alg, e: e, ext: ext, key_ops: key_ops, n: n};
  return (!(tmp == null) ? !(tmp == null) : false) ? tmp : THROW_CCE();
}
function toPrivateJwk_0(_this__u8e3s4) {
  var tmp$ret$1;
  $l$block: {
    // Inline function 'kotlin.requireNotNull' call
    var value = _this__u8e3s4.alg;
    // Inline function 'kotlin.contracts.contract' call
    if (value == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPrivateJwk.<anonymous>' call
      var message = "alg can't be null for a private JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message));
    } else {
      tmp$ret$1 = value;
      break $l$block;
    }
  }
  var tmp = tmp$ret$1;
  var tmp$ret$3;
  $l$block_0: {
    // Inline function 'kotlin.requireNotNull' call
    var value_0 = _this__u8e3s4.d;
    // Inline function 'kotlin.contracts.contract' call
    if (value_0 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPrivateJwk.<anonymous>' call
      var message_0 = "d can't be null for a private JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_0));
    } else {
      tmp$ret$3 = value_0;
      break $l$block_0;
    }
  }
  var tmp_0 = tmp$ret$3;
  var tmp$ret$5;
  $l$block_1: {
    // Inline function 'kotlin.requireNotNull' call
    var value_1 = _this__u8e3s4.dp;
    // Inline function 'kotlin.contracts.contract' call
    if (value_1 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPrivateJwk.<anonymous>' call
      var message_1 = "dp can't be null for a private JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_1));
    } else {
      tmp$ret$5 = value_1;
      break $l$block_1;
    }
  }
  var tmp_1 = tmp$ret$5;
  var tmp$ret$7;
  $l$block_2: {
    // Inline function 'kotlin.requireNotNull' call
    var value_2 = _this__u8e3s4.dq;
    // Inline function 'kotlin.contracts.contract' call
    if (value_2 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPrivateJwk.<anonymous>' call
      var message_2 = "dq can't be null for a private JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_2));
    } else {
      tmp$ret$7 = value_2;
      break $l$block_2;
    }
  }
  var tmp_2 = tmp$ret$7;
  var tmp$ret$9;
  $l$block_3: {
    // Inline function 'kotlin.requireNotNull' call
    var value_3 = _this__u8e3s4.e;
    // Inline function 'kotlin.contracts.contract' call
    if (value_3 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPrivateJwk.<anonymous>' call
      var message_3 = "e can't be null for a private JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_3));
    } else {
      tmp$ret$9 = value_3;
      break $l$block_3;
    }
  }
  var tmp_3 = tmp$ret$9;
  var tmp$ret$11;
  $l$block_4: {
    // Inline function 'kotlin.requireNotNull' call
    var value_4 = _this__u8e3s4.ext;
    // Inline function 'kotlin.contracts.contract' call
    if (value_4 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPrivateJwk.<anonymous>' call
      var message_4 = "ext can't be null for a private JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_4));
    } else {
      tmp$ret$11 = value_4;
      break $l$block_4;
    }
  }
  var tmp_4 = tmp$ret$11;
  var tmp$ret$13;
  $l$block_5: {
    // Inline function 'kotlin.requireNotNull' call
    var value_5 = _this__u8e3s4.key_ops;
    // Inline function 'kotlin.contracts.contract' call
    if (value_5 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPrivateJwk.<anonymous>' call
      var message_5 = "key_ops can't be null for a private JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_5));
    } else {
      tmp$ret$13 = value_5;
      break $l$block_5;
    }
  }
  var tmp_5 = toSet(tmp$ret$13);
  var tmp$ret$15;
  $l$block_6: {
    // Inline function 'kotlin.requireNotNull' call
    var value_6 = _this__u8e3s4.n;
    // Inline function 'kotlin.contracts.contract' call
    if (value_6 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPrivateJwk.<anonymous>' call
      var message_6 = "n can't be null for a private JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_6));
    } else {
      tmp$ret$15 = value_6;
      break $l$block_6;
    }
  }
  var tmp_6 = tmp$ret$15;
  var tmp$ret$17;
  $l$block_7: {
    // Inline function 'kotlin.requireNotNull' call
    var value_7 = _this__u8e3s4.p;
    // Inline function 'kotlin.contracts.contract' call
    if (value_7 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPrivateJwk.<anonymous>' call
      var message_7 = "p can't be null for a private JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_7));
    } else {
      tmp$ret$17 = value_7;
      break $l$block_7;
    }
  }
  var tmp_7 = tmp$ret$17;
  var tmp$ret$19;
  $l$block_8: {
    // Inline function 'kotlin.requireNotNull' call
    var value_8 = _this__u8e3s4.q;
    // Inline function 'kotlin.contracts.contract' call
    if (value_8 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPrivateJwk.<anonymous>' call
      var message_8 = "q can't be null for a private JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_8));
    } else {
      tmp$ret$19 = value_8;
      break $l$block_8;
    }
  }
  var tmp_8 = tmp$ret$19;
  var tmp$ret$21;
  $l$block_9: {
    // Inline function 'kotlin.requireNotNull' call
    var value_9 = _this__u8e3s4.qi;
    // Inline function 'kotlin.contracts.contract' call
    if (value_9 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPrivateJwk.<anonymous>' call
      var message_9 = "qi can't be null for a private JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_9));
    } else {
      tmp$ret$21 = value_9;
      break $l$block_9;
    }
  }
  return new PrivateRsaKeyJwk(tmp, tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, tmp_7, tmp_8, tmp$ret$21);
}
function toPublicJwk_0(_this__u8e3s4) {
  var tmp$ret$1;
  $l$block: {
    // Inline function 'kotlin.requireNotNull' call
    var value = _this__u8e3s4.alg;
    // Inline function 'kotlin.contracts.contract' call
    if (value == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPublicJwk.<anonymous>' call
      var message = "alg can't be null for a public JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message));
    } else {
      tmp$ret$1 = value;
      break $l$block;
    }
  }
  var tmp = tmp$ret$1;
  var tmp$ret$3;
  $l$block_0: {
    // Inline function 'kotlin.requireNotNull' call
    var value_0 = _this__u8e3s4.e;
    // Inline function 'kotlin.contracts.contract' call
    if (value_0 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPublicJwk.<anonymous>' call
      var message_0 = "e can't be null for a public JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_0));
    } else {
      tmp$ret$3 = value_0;
      break $l$block_0;
    }
  }
  var tmp_0 = tmp$ret$3;
  var tmp$ret$5;
  $l$block_1: {
    // Inline function 'kotlin.requireNotNull' call
    var value_1 = _this__u8e3s4.ext;
    // Inline function 'kotlin.contracts.contract' call
    if (value_1 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPublicJwk.<anonymous>' call
      var message_1 = "ext can't be null for a public JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_1));
    } else {
      tmp$ret$5 = value_1;
      break $l$block_1;
    }
  }
  var tmp_1 = tmp$ret$5;
  var tmp$ret$7;
  $l$block_2: {
    // Inline function 'kotlin.requireNotNull' call
    var value_2 = _this__u8e3s4.key_ops;
    // Inline function 'kotlin.contracts.contract' call
    if (value_2 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPublicJwk.<anonymous>' call
      var message_2 = "key_ops can't be null for a public JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_2));
    } else {
      tmp$ret$7 = value_2;
      break $l$block_2;
    }
  }
  var tmp_2 = toSet(tmp$ret$7);
  var tmp$ret$9;
  $l$block_3: {
    // Inline function 'kotlin.requireNotNull' call
    var value_3 = _this__u8e3s4.n;
    // Inline function 'kotlin.contracts.contract' call
    if (value_3 == null) {
      // Inline function 'com.icure.kryptom.crypto.external.toPublicJwk.<anonymous>' call
      var message_3 = "n can't be null for a public JsonWebKey";
      throw IllegalArgumentException_init_$Create$(toString(message_3));
    } else {
      tmp$ret$9 = value_3;
      break $l$block_3;
    }
  }
  return new PublicRsaKeyJwk(tmp, tmp_0, tmp_1, tmp_2, tmp$ret$9);
}
function toKryptom_6(_this__u8e3s4, algorithm) {
  if (!(_this__u8e3s4.algorithm === algorithm.a5m())) {
    throw AssertionError_init_$Create$('Algorithm mismatch: ' + _this__u8e3s4.algorithm + ' != ' + algorithm.a5m());
  }
  return new PrivateRsaKey(_this__u8e3s4.privateKey, algorithm);
}
function toKryptom_7(_this__u8e3s4, algorithm) {
  if (!(_this__u8e3s4.algorithm === algorithm.a5m())) {
    throw AssertionError_init_$Create$('Algorithm mismatch: ' + _this__u8e3s4.algorithm + ' != ' + algorithm.a5m());
  }
  return new PublicRsaKey(_this__u8e3s4.publicKey, algorithm);
}
function toByteArray_0(_this__u8e3s4) {
  // Inline function 'kotlin.js.unsafeCast' call
  // Inline function 'kotlin.js.asDynamic' call
  return new Int8Array(_this__u8e3s4);
}
function toArrayBuffer(_this__u8e3s4) {
  return (new Int8Array(toTypedArray(_this__u8e3s4))).buffer;
}
function parsingDynamic(obj, block) {
  return block(new DynamicParser(obj));
}
function DynamicParser(obj) {
  this.j5v_1 = obj;
}
function get_jsCrypto() {
  _init_properties_JsCrypto_kt__ooos6();
  // Inline function 'kotlin.getValue' call
  var this_0 = jsCrypto$delegate;
  jsCrypto$factory();
  return this_0.b1();
}
var jsCrypto$delegate;
function hasNodeApi() {
  _init_properties_JsCrypto_kt__ooos6();
  return typeof process !== 'undefined' && process.versions != null && process.versions.node != null || (typeof window !== 'undefined' && typeof window.process !== 'undefined' && window.process.versions != null && window.process.versions.node != null);
}
function jsCrypto$delegate$lambda() {
  _init_properties_JsCrypto_kt__ooos6();
  var tmp;
  if (hasNodeApi()) {
    tmp = typeof crypto != 'undefined' ? crypto : typeof require != 'undefined' ? eval('require')('crypto') : undefined;
  } else {
    tmp = window ? window.crypto ? window.crypto : window.msCrypto : self.crypto;
  }
  var loaded = tmp;
  if (loaded == null) {
    throw IllegalStateException_init_$Create$('Js crypto is not available.\nTo use kryptom with node and ES modules you need to use node 19 or later.\nTo use kryptom in expo / react native use the @icure/expo-kryptom npm package.');
  }
  return loaded;
}
function jsCrypto$factory() {
  return getPropertyCallableRef('jsCrypto', 0, KProperty0, function () {
    return get_jsCrypto();
  }, null);
}
var properties_initialized_JsCrypto_kt_lvaqdw;
function _init_properties_JsCrypto_kt__ooos6() {
  if (!properties_initialized_JsCrypto_kt_lvaqdw) {
    properties_initialized_JsCrypto_kt_lvaqdw = true;
    jsCrypto$delegate = lazy(jsCrypto$delegate$lambda);
  }
}
function PlatformMethodException(message) {
  Exception_init_$Init$(message, this);
  captureStack(this, PlatformMethodException);
}
//region block: post-declaration
protoOf(Asn1Integer).z5o = getTag;
protoOf(Asn1OctetString).z5o = getTag;
protoOf(Asn1Sequence).z5o = getTag;
protoOf(Asn1Enumerated).z5o = getTag;
protoOf(Asn1Null).z5o = getTag;
protoOf(Asn1Oid).z5o = getTag;
protoOf(Asn1Boolean).z5o = getTag;
protoOf(Asn1BitString).z5o = getTag;
protoOf(JsAesService).q5k = generateKey$default;
protoOf(JsAesService).u5k = encrypt$default;
protoOf(JsHmacService).c5l = generateKey$default_0;
protoOf(JsStrongRandom).u5o = randomBytes;
defineProp(protoOf(XServiceAdapter), 'aes', function () {
  return this.w5k();
});
defineProp(protoOf(XServiceAdapter), 'digest', function () {
  return this.z5k();
});
defineProp(protoOf(XServiceAdapter), 'rsa', function () {
  return this.x5k();
});
defineProp(protoOf(XServiceAdapter), 'strongRandom', function () {
  return this.y5k();
});
defineProp(protoOf(XServiceAdapter), 'hmac', function () {
  return this.a5l();
});
protoOf(AesServiceAdapter).q5k = generateKey$default;
protoOf(AesServiceAdapter).u5k = encrypt$default;
protoOf(HmacServiceAdapter).c5l = generateKey$default_0;
//endregion
//region block: init
CbcWithPkcs7Padding_instance = new CbcWithPkcs7Padding();
Companion_instance = new Companion();
HmacSha512_instance = new HmacSha512();
HmacSha256_instance = new HmacSha256();
Companion_instance_0 = new Companion_0();
Companion_instance_1 = new Companion_1();
OaepWithSha1_instance = new OaepWithSha1();
OaepWithSha256_instance = new OaepWithSha256();
Companion_instance_2 = new Companion_2();
PssWithSha256_instance = new PssWithSha256();
Companion_instance_3 = new Companion_3();
AsnUtils_instance = new AsnUtils();
AsnToJwkConverter_instance = new AsnToJwkConverter();
JsDigestService_instance = new JsDigestService();
JsHmacService_instance = new JsHmacService();
JsStrongRandom_instance = new JsStrongRandom();
//endregion
//region block: exports
export {
  adaptCryptoServiceForExternal as adaptCryptoServiceForExternal2gvqebvv452w2,
  adaptExternalCryptoService as adaptExternalCryptoService1ul8uw60bqm2i,
  toExternal_1 as toExternal25t96vkonv7dl,
  toKryptomEncryption as toKryptomEncryption9znnmw3w4ev1,
  toKryptomEncryption_0 as toKryptomEncryption38aqwasaxbvpt,
  toKryptom_3 as toKryptom3nnydy8sujoyh,
  AesKey as AesKey1u17f651xzolb,
  CryptoService as CryptoService1hef2zwqo9pxt,
  PrivateRsaKeyJwk as PrivateRsaKeyJwk2y50clo3xvrsi,
  RsaEncryptionAlgorithm as RsaEncryptionAlgorithm1tujda13ihdp7,
  RsaKeypair as RsaKeypair2r3p9jmufcllb,
  get_defaultCryptoService as get_defaultCryptoService3se6h24t6bp5v,
  base32Decode as base32Decode2jbdu2t0l4088,
  base32Encode as base32Encodekmf3yf2s0juj,
  base64Decode as base64Decodes731id9on7gy,
  base64Encode as base64Encode2qlepsvd3tele,
  hexToByteArray_0 as hexToByteArray3fb7kdnap6dyp,
  toHexString_1 as toHexStringu73q9mlb2b2a,
  KeySize_Aes128_getInstance as KeySize_Aes128_getInstance1bm0ygwj0kpf7,
  KeySize_Aes256_getInstance as KeySize_Aes256_getInstance2yudd9b194afk,
  KeySize_Rsa2048_getInstance as KeySize_Rsa2048_getInstance19b5up56gxgco,
  AsnToJwkConverter_instance as AsnToJwkConverter_instance1vwkdsob7z5kb,
  CbcWithPkcs7Padding_instance as CbcWithPkcs7Padding_instance2a9bnftdhgmb,
  HmacSha512_instance as HmacSha512_instance1eqnxnszs1gyx,
  Companion_instance_1 as Companion_instancelgfzc5nwjqo,
  OaepWithSha1_instance as OaepWithSha1_instance2lfkc4a2j8bvo,
  OaepWithSha256_instance as OaepWithSha256_instance1yt3ijpuuc4mw,
};
//endregion

//# sourceMappingURL=kryptom-lib.mjs.map
