{"version":3,"file":"AuthenticationMethod.mjs","sourceRoot":"","sources":["../../tsSourcesProject/options/AuthenticationMethod.mts"],"names":[],"mappings":"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","sourcesContent":["import {AuthenticationClass} from \"../model/embed/AuthenticationClass.mjs\";\nimport {CaptchaOptions} from \"../auth/CaptchaOptions.mjs\";\n\nexport enum ThirdPartyProvider {\n  GOOGLE = \"GOOGLE\"\n}\n\nexport namespace AuthenticationMethod {\n  /**\n   * The sdk will perform requests using jwt obtained from the provided credentials.\n   *\n   * When using this authentication method, the sdk will cache the credentials and will automatically request updated\n   * tokens as needed.\n   * However, if the provided credentials expire, the SDK will become unusable.\n   *\n   * This authentication method can also be used for the execution of requests that require an elevated security context\n   * as long as the credentials provided can be used to create a suitable token.\n   *\n   * Not that when using this authentication method the provided credentials will be cached (in volatile memory)\n   * without expiration.\n   */\n  export namespace UsingCredentials {\n    export class UsernamePassword {\n      constructor(\n        /**\n         * A public identifier of the user logging in. This could be:\n         * - {@link User.id}\n         * - {@link Group.id}:{@link User.id}\n         * - {@link User.login}\n         * - {@link User.email}\n         */\n        readonly username: string,\n        /**\n         * The password of the user\n         */\n        readonly password: string,\n      ) {}\n    }\n\n    export class UsernameLongToken {\n      constructor(\n        /**\n         * A public identifier of the user logging in. This could be:\n         * - {@link User.id}\n         * - {@link Group.id}:{@link User.id}\n         * - {@link User.login}\n         * - {@link User.email}\n         */\n        readonly username: string,\n        /**\n         * A long-lived token of the user\n         */\n        readonly token: string,\n      ) {}\n    }\n\n    export class ThirdPartyAuth {\n      constructor(\n        /**\n         * A token used to perform the third party authentication\n         */\n        readonly token: string,\n        /**\n         * The authentication provider\n         */\n        readonly provider: ThirdPartyProvider,\n      ) {}\n    }\n\n    export class JwtCredentials {\n      constructor(\n        /**\n         * A refresh token of the user\n         */\n        readonly refresh: string,\n        /**\n         * An initial bearer token of the user, optional.\n         */\n        readonly bearer?: string\n      ) {}\n    }\n  }\n\n  /**\n   * Allows the SDK to perform authentication using secrets obtained from an [AuthSecretProvider].\n   *\n   * The iCure SDK can authenticate to the backend using different kinds of secrets, such as passwords, long-lived authentication tokens, and\n   * short-lived authentication tokens generated through the message gateway.\n   * iCure associates to each kind of secret a certain security level, and for some sensitive operations, depending on the configurations of\n   * the user and his group, some operations may require a secret of a certain security level.\n   *\n   * For example, with the default configurations, to change his own email the user can't have logged in with a long-lived token, but he\n   * needs to provide his current password or a short-lived token.\n   *\n   * By using this authentication option, the iCure SDK will automatically request and cache the secret from the [AuthSecretProvider] only when\n   * needed, which should help to minimize the interaction with the user.\n   *\n   * Another advantage of using this authentication option over others is that in case all the cached tokens and secrets were to expire while\n   * performing a request, instead of having the request fail the SDK will ask for a new secret from the [SmartAuthProvider] and the request will\n   * automatically be retried with the new secret.\n   */\n  export class UsingSecretProvider {\n    constructor(\n      readonly secretProvider: AuthSecretProvider,\n      readonly options?: SecretProviderAuthenticationOptions\n    ) {}\n  }\n}\nexport type AuthenticationMethod =\n  AuthenticationMethod.UsingCredentials.UsernamePassword |\n  AuthenticationMethod.UsingCredentials.UsernameLongToken |\n  AuthenticationMethod.UsingCredentials.ThirdPartyAuth |\n  AuthenticationMethod.UsingCredentials.JwtCredentials |\n  AuthenticationMethod.UsingSecretProvider\n\nexport interface SecretProviderAuthenticationOptions {\n  /**\n   * A public identifier of the user logging in. This could be:\n   * - {@link User.id}\n   * - {@link Group.id}:{@link User.id}\n   * - {@link User.login}\n   * - {@link User.email}\n   * This value is optional because authentication using external methods (e.g. Google or digital ids) does not\n   * require explicitly providing the username. However, if not provided, the authentication will be locked to\n   * only use these external authentication methods.\n   */\n  readonly loginUsername?: string\n  /**\n   * An initial secret for the login.\n   * If not null, the authentication provider will attempt to use it when needed before asking the secret\n   * provider.\n   */\n  readonly initialSecret?: SecretProviderAuthenticationOptions.InitialSecret\n  /**\n   * If not null the authentication provider will use the jwt while valid.\n   */\n  readonly existingJwt?: string\n  /**\n   * If not null the authentication provider will use the refresh jwt while valid.\n   */\n  readonly existingRefreshJwt?: string\n  /**\n   * If set to true the secrets used by the authentication provider will be cached without expiration\n   * (in volatile memory).\n   * This minimizes the interaction with the end user, but may not be suitable for your security policy.\n   */\n  readonly cacheSecrets?: boolean\n}\n\nexport namespace SecretProviderAuthenticationOptions {\n  export namespace InitialSecret {\n    export class Password { constructor(readonly password: string) {} }\n    export class LongLivedToken { constructor(readonly token: string) {} }\n    export class OAuth { constructor(readonly secret: string, readonly oauthType: ThirdPartyProvider) {} }\n  }\n\n  export type InitialSecret = InitialSecret.Password | InitialSecret.LongLivedToken | InitialSecret.OAuth\n}\n\nexport interface AuthSecretProvider {\n  /**\n   * Provides a secret for authentication to the iCure SDK.\n   *\n   * ## Accepted secrets\n   *\n   * The method will be provided with an array of the secrets types that are acceptable {@link acceptedSecrets}. Usually this array will contain multiple\n   * elements, but this depends on the group configuration, the user (if he has 2fa setup or not), or the operation being performed. For groups using\n   * default configurations and for patients without 2fa enabled for example the array will always contain the {@link AuthenticationClass.Password} element.\n   * Usually the array contain also the {@link AuthenticationClass.LongLivedToken} element, but if the user is attempting to perform a sensitive operations\n   * such as changing his password the default group configuration does not allow for the user to authenticate using a JWT obtained from a long-lived\n   * token for this operation, meaning the array will not contain the {@link AuthenticationClass.LongLivedToken} element.\n   *\n   * Regardless of the number of elements in the array only one secret of the accepted types is sufficient for the operation to succeed.\n   *\n   * ## {@link AuthenticationClass.TwoFactorAuthentication} secret type\n   *\n   * The {@link AuthenticationClass.TwoFactorAuthentication} secret type is only used when the user has 2fa enabled. In this case the SDK will call\n   * this method twice, once containing the {@link AuthenticationClass.Password} element in the {@link acceptedSecrets} array, and if the provided secret is a\n   * valid password the SDK will immediately call this method again, this time containing the {@link AuthenticationClass.TwoFactorAuthentication}\n   * instead of the {@link AuthenticationClass.Password} element.\n   *\n   * Any future call to this method from the same provider instance will not contain the {@link AuthenticationClass.Password} element anymore, as it is\n   * cached, but it may contain the {@link AuthenticationClass.TwoFactorAuthentication} element instead.\n   *\n   * Note that the 2fa token is not needed for logging in through a long-lived or short-lived token, it is only used in combination with a password.\n   * If the user is using 2fa, and you get in input as {@link acceptedSecrets} an array `[PASSWORD, LONG_LIVED_TOKEN, SHORT_LIVED_TOKEN]`, and you pass to\n   * authenticate a long-lived token, the SDK will not call this method again to ask for the 2fa token.\n   *\n   * @param acceptedSecrets the types of secrets that are acceptable for the operation being performed.\n   * @param previousAttempts the secrets that were previously attempted by the SDK for this operation. This array will be empty the first time this\n   * method is called for a given operation, but it may contain multiple elements if the SDK has already called this method multiple times because the\n   * previously returned secrets were not valid. The first element is the first secret that was attempted, and the last element is the most recently\n   * attempted.\n   * @param authProcessApi an api which can be used to request sms or email short-lived tokens for the user.\n   * @return a promise that resolves with the secret and the secret type to use for authentication. If the promise rejects then the ongoing SDK\n   * operation will fail without being re-attempted.\n   */\n  getSecret(\n    acceptedSecrets: Array<AuthenticationClass>,\n    previousAttempts: Array<AuthSecretDetails>,\n    authProcessApi: AuthenticationProcessApi\n  ): Promise<AuthSecretDetails>\n}\n\nexport namespace AuthSecretDetails {\n  export class PasswordDetails {\n    /**\n     * @param secret the password of the user\n     */\n    constructor (readonly secret: String) {}\n  }\n  \n  export class TwoFactorAuthTokenDetails {\n    /**\n     * @param secret the current two-factor authentication token of the user.\n     */\n    constructor (readonly secret: String) {}\n  }\n\n  export class ShortLivedTokenDetails {\n    /**\n     * @param secret a short-lived token obtained through an authentication process\n     * @param authenticationProcessInfo the authentication process that was used to create the secret\n     */\n    constructor(readonly secret: String, readonly authenticationProcessInfo: AuthenticationProcessRequest) {}\n  }\n  \n  export class LongLivedTokenDetails {\n    /**\n     * @param secret a long-lived token of the user.\n     */\n    constructor (readonly secret: String) {}\n  }\n  \n  export class ExternalAuthenticationDetails {\n    /**\n     * @param secret some token or another secret that can be used to authenticate the user to a supported third party service\n     * @param oauthType the third party service that should recognize the provided secret.\n     */\n    constructor (readonly secret: String, readonly oauthType: ThirdPartyProvider) {}\n  }\n  \n  export class DigitalIdDetails {\n    /**\n     * Not yet implemented\n     */\n    constructor (readonly secret: String) {}\n  }\n}\nexport type AuthSecretDetails =\n  AuthSecretDetails.PasswordDetails |\n  AuthSecretDetails.TwoFactorAuthTokenDetails |\n  AuthSecretDetails.ShortLivedTokenDetails |\n  AuthSecretDetails.LongLivedTokenDetails |\n  AuthSecretDetails.ExternalAuthenticationDetails |\n  AuthSecretDetails.DigitalIdDetails\n\n/**\n * Allows initializing processes for the registration and authentication of users.\n */\nexport interface AuthenticationProcessApi {\n  /**\n   * Executes an authentication process.\n   * @param messageGatewayUrl the url of the iCure message gateway you want to use. Usually this should be\n   * @param externalServicesSpecId an identifier that allows the message gateway to connect the request to your\n   * services for email / sms communication of the process tokens.\n   * @param processId the id of the process you want to execute.\n   * @param userTelecomType the type of telecom number used for the user.\n   * @param userTelecom the telecom number of the user for which you want to execute the process. This should be an\n   * email address or phone number depending on the type of process you are executing.\n   * @param captchaOptions the captcha solution\n   * @param processTemplateParameters additional parameters needed by some process templates.\n   */\n  executeProcess(\n    messageGatewayUrl: string,\n    externalServicesSpecId: string,\n    processId: string,\n    userTelecomType: AuthenticationProcessTelecomType,\n    userTelecom: string,\n    captchaOptions: CaptchaOptions,\n    processTemplateParameters?: AuthenticationProcessTemplateParameters\n  ): Promise<AuthenticationProcessRequest>\n}\n\nexport interface AuthenticationProcessTemplateParameters {\n  /**\n   * First name of the user executing the authentication process.\n   */\n  readonly firstName?: string\n  /**\n   * Last name of the user executing the authentication process.\n   */\n  readonly lastName?: string\n}\n\nexport enum AuthenticationProcessTelecomType {\n  Email = \"Email\", MobilePhone = \"MobilePhone\"\n}\n\n/**\n * Holds information on an authentication process request done through the {@link AuthenticationProcessApi}.\n *\n * You should not instantiate this class directly or use its properties, as they are for internal use and may be changed\n * without notice.\n */\nexport class AuthenticationProcessRequest {\n  constructor(\n    readonly messageGwUrl: String,\n    readonly specId: String,\n    readonly requestId: String\n  ) {}\n}"]}