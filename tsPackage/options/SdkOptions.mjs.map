{"version":3,"file":"SdkOptions.mjs","sourceRoot":"","sources":["../../tsSourcesProject/options/SdkOptions.mts"],"names":[],"mappings":"","sourcesContent":["import {XCryptoService} from \"../crypto/CryptoService.mjs\";\nimport {UserGroup} from \"../model/UserGroup.mjs\";\nimport {KeyStorageFacade} from \"../storage/StorageFacade.mjs\";\nimport {CryptoStrategies} from \"../crypto/CryptoStrategies.mjs\";\nimport {CardinalKeyStorageOptions} from \"../cardinal-sdk-ts.mjs\";\n\nexport interface SdkOptions {\n  /**\n   * Configure which fields of entities should be encrypted\n   */\n  readonly encryptedFields?: EncryptedFieldsConfiguration\n  /**\n   * Has only effect when logging in as an hcp user.\n   *\n   * If true the api will be initialized in a hierarchical mode, where each data owner is considered to have access\n   * to all data of his parents (requires corresponding permission on the server side).\n   * In this case the sdk will also expect to have access to at least a key for each parent data owner of the current\n   * user.\n   *\n   * If false or undefined the api will ignore the data owner hierarchies.\n   * Each data owner is considered to have access only to data shared explicitly with him, and has access only to his\n   * own keys.\n   */\n  readonly useHierarchicalDataOwners?: boolean\n  /**\n   * If true (default) the sdk will automatically create the transfer keys for the current user if a new keypair is\n   * created.\n   */\n  readonly createTransferKeys?: boolean\n  /**\n   * Service for encryption primitives.\n   */\n  readonly cryptoService?: XCryptoService\n  /**\n   * If true (default) the password of the user will be salted together with the application id before sending it to\n   * the iCure backend for login or when changing the user password.\n   * This is done in addition to the server-side salting of the password before storing them.\n   *\n   * By enabling this option iCure never gets access to the plain text password of users.\n   * Note that changing this value in a second moment requires also modifying the password of the user on the iCure\n   * databases to reflect the change.\n   */\n  readonly saltPasswordWithApplicationId?: boolean\n  /**\n   * An instance of iCure SDK is initialized for working as a specific user in a single group.\n   * However, the user credentials may match multiple users in different groups (but at most one per group).\n   * If that is the case, this function will be used to pick the actual user for which the sdk will be initialized.\n   *\n   * This is mandatory in multi-group applications, where a single user could exist in multiple groups.\n   * If this parameter is null and the user credentials match multiple users the api initialisation will fail.\n   * In single-group applications this parameter won't be used, so it can be left as null.\n   */\n  readonly groupSelector?: (availableGroups: Array<UserGroup>) => Promise<string>\n  /**\n   * Options to support the migration of data created using iCure versions from before 2018.\n   * Leave it as false (default) unless explicitly instructed to set it to true by the iCure team.\n   */\n  readonly autoCreateEncryptionKeyForExistingLegacyData?: boolean\n  /**\n   * Implementation of key storage to use.\n   * If not provided the sdk will store the keys in the StorageFacade provided to the api initialization method.\n   */\n  readonly keyStorage?: KeyStorageFacade | CardinalKeyStorageOptions\n  /**\n   * Custom crypto strategies. If not provided the sdk will use crypto strategies that:\n   * - Allow for the creation of a new key of the data owner\n   * - Do not use any custom key recovery solutions\n   * - Considers any keys recovered using iCure's recovery methods as unverified\n   * - Considers all public keys of other data owners as verified\n   * - Considers patients as anonymous data owners\n   */\n  readonly cryptoStrategies?: CryptoStrategies\n  /**\n   * Patcher for the decrypted entities json.\n   * This allows adapting to changes in the data model of entities even if the changes are done to the encrypted part\n   * of the entity.\n   */\n  readonly jsonPatcher?: JsonPatcher\n  /**\n   * If true the SDK will use lenient deserialization of the entities coming from the backend.\n   *\n   * This could be helpful when developing using the nightly deployments of the backend, as the SDK will ignore minor changes to the data model.\n   *\n   * This option however could cause loss of data when connecting with incompatible versions of the backend, and should be disabled in production.\n   */\n  readonly lenientJson?: boolean\n}\n\nexport interface BasicSdkOptions {\n  /**\n   * Configure which fields of entities should be encrypted\n   */\n  readonly encryptedFields?: EncryptedFieldsConfiguration\n  /**\n   * Service for encryption primitives.\n   */\n  readonly cryptoService?: XCryptoService\n  /**\n   * If true (default) the password of the user will be salted together with the application id before sending it to\n   * the iCure backend for login or when changing the user password.\n   * This is done in addition to the server-side salting of the password before storing them.\n   *\n   * By enabling this option iCure never gets access to the plain text password of users.\n   * Note that changing this value in a second moment requires also modifying the password of the user on the iCure\n   * databases to reflect the change.\n   */\n  readonly saltPasswordWithApplicationId?: boolean\n  /**\n   * An instance of iCure SDK is initialized for working as a specific user in a single group.\n   * However, the user credentials may match multiple users in different groups (but at most one per group).\n   * If that is the case, this function will be used to pick the actual user for which the sdk will be initialized.\n   *\n   * This is mandatory in multi-group applications, where a single user could exist in multiple groups.\n   * If this parameter is null and the user credentials match multiple users the api initialisation will fail.\n   * In single-group applications this parameter won't be used, so it can be left as null.\n   */\n  readonly groupSelector?: (availableGroups: Array<UserGroup>) => Promise<string>\n  /**\n   * If true the SDK will use lenient deserialization of the entities coming from the backend.\n   *\n   * This could be helpful when developing using the nightly deployments of the backend, as the SDK will ignore minor changes to the data model.\n   *\n   * This option however could cause loss of data when connecting with incompatible versions of the backend, and should be disabled in production.\n   */\n  readonly lenientJson?: boolean\n}\n\nexport interface EncryptedFieldsConfiguration {\n  readonly accessLog?: Array<string>\n  readonly calendarItem?: Array<string>\n  readonly contact?: Array<string>\n  readonly service?: Array<string>\n  readonly healthElement?: Array<string>\n  readonly maintenanceTask?: Array<string>\n  readonly patient?: Array<string>\n  readonly message?: Array<string>\n  readonly topic?: Array<string>\n  readonly document?: Array<string>\n  readonly form?: Array<string>\n  readonly receipt?: Array<string>\n  readonly classification?: Array<string>\n  readonly timeTable?: Array<string>\n  readonly invoice?: Array<string>\n}\n\n/**\n * Provides methods to patch the json representing a certain type of entity after decryption and before validation and\n * proper deserialization.\n * Each of these methods takes in input the parsed json of the decrypted entity and must return the patched json.\n * All the patchers are optional, if you don't define a patcher the json of the entity will be used by the sdk as is\n * without any patching.\n *\n *\n */\nexport interface JsonPatcher {\n  /**\n   * Patches the decrypted json of an AccessLog\n   */\n  readonly patchAccessLog?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a CalendarItem\n   */\n  readonly patchCalendarItem?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a Contact\n   */\n  readonly patchContact?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a Service.\n   * This method is used only when a service is retrieved by itself, without the rest of the contact.\n   * Services retrieved as part of a contact should be patched as part of {@link patchContact}\n   */\n  readonly patchIndividualService?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a HealthElement\n   */\n  readonly patchHealthElement?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a MaintenanceTask\n   */\n  readonly patchMaintenanceTask?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a Patient\n   */\n  readonly patchPatient?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a Message\n   */\n  readonly patchMessage?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a Topic\n   */\n  readonly patchTopic?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a Document\n   */\n  readonly patchDocument?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a Form\n   */\n  readonly patchForm?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a Receipt\n   */\n  readonly patchReceipt?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a Classification\n   */\n  readonly patchClassification?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a TimeTable\n   */\n  readonly patchTimeTable?: ((json: any) => any)\n  /**\n   * Patches the decrypted json of a Invoice\n   */\n  readonly patchInvoice?: ((json: any) => any)\n}\n"]}