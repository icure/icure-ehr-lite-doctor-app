{"version":3,"file":"StorageFacade.mjs","sourceRoot":"","sources":["../../tsSourcesProject/storage/StorageFacade.mts"],"names":[],"mappings":"AAAA,OAAO,EAGN,wCAAwC,EACxC,qCAAqC,EACrC,MAAM,wBAAwB,CAAC;AA4BhC,MAAM,KAAW,aAAa,CAgB7B;AAhBD,WAAiB,aAAa;IAC7B;;;;OAIG;IACH,SAAgB,eAAe,CAAC,SAAiB;QAChD,OAAO,qCAAqC,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAA;IACjF,CAAC;IAFe,6BAAe,kBAE9B,CAAA;IACD;;;OAGG;IACH,SAAgB,wBAAwB;QACvC,OAAO,qCAAqC,CAAC,WAAW,EAAE,CAAC,mBAAmB,EAAE,CAAA;IACjF,CAAC;IAFe,sCAAwB,2BAEvC,CAAA;AACF,CAAC,EAhBgB,aAAa,KAAb,aAAa,QAgB7B;AA2CD,MAAM,KAAW,gBAAgB,CAgBhC;AAhBD,WAAiB,gBAAgB;IAChC;;;OAGG;IACH,SAAgB,gBAAgB,CAAC,WAAmD;QACnF,OAAO,wCAAwC,CAAC,WAAW,EAAE,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAA;IAC5F,CAAC;IAFe,iCAAgB,mBAE/B,CAAA;IAED;;;OAGG;IACH,SAAgB,aAAa,CAAC,WAAmD;QAChF,OAAO,wCAAwC,CAAC,WAAW,EAAE,CAAC,aAAa,CAAC,WAAW,CAAC,CAAA;IACzF,CAAC;IAFe,8BAAa,gBAE5B,CAAA;AACF,CAAC,EAhBgB,gBAAgB,KAAhB,gBAAgB,QAgBhC","sourcesContent":["import {\n\tCardinalKeyStorageOptions,\n\tCardinalStorageOptions,\n\tInternalCardinalKeyStorageOptionsFactory,\n\tInternalCardinalStorageOptionsFactory\n} from \"../cardinal-sdk-ts.mjs\";\n\n/**\n * Provides permanent storage capabilities to the SDK\n */\nexport interface StorageFacade {\n\t/**\n\t * Returns the value of the provided key from the storage\n\t * @param key Key of the value to retrieve\n\t * @return The value associated to the provided key or null if there is no value stored at the provided key.\n\t */\n\tgetItem(key: string): Promise<string | undefined>\n\n\t/**\n\t * Set an item in the storage for the given key. If an item already exists for the given key, it will be overwritten.\n\t * @param key Key of the value to set\n\t * @param value the value to store\n\t */\n\tsetItem(key: string, value: string): Promise<void>\n\n\t/**\n\t * Removes the item with the given key from the storage, if present.\n\t * Does nothing if there is no value.\n\t * @param key The key of the item to remove.\n\t */\n\tremoveItem(key: string): Promise<void>\n}\n\nexport namespace StorageFacade {\n\t/**\n\t * Factory method returning storage options that will cause the sdk to store the data as files at the provided\n\t * directory. These options are usable only on node.\n\t * @param directory\n\t */\n\texport function usingFileSystem(directory: string): CardinalStorageOptions {\n\t\treturn InternalCardinalStorageOptionsFactory.getInstance().fileSystem(directory)\n\t}\n\t/**\n\t * Factory method returning storage options that will cause the sdk to store the data as entries on the browser\n\t * local storage. These options require the `localStorage` global to be available\n\t */\n\texport function usingBrowserLocalStorage(): CardinalStorageOptions {\n\t\treturn InternalCardinalStorageOptionsFactory.getInstance().browserLocalStorage()\n\t}\n}\n\nexport interface KeyStorageFacade {\n\t/**\n\t * Returns the publicKey of the provided key from the storage\n\t * @param storageEntryKey Key of the value to retrieve\n\t * @return The publicKey associated to the provided storageEntryKey in spki format or null if no entry has such key.\n\t * @throws IllegalEntityException if there is a value stored at the provided entry key, but it is not a public key\n\t */\n\tgetPublicKeySpki(storageEntryKey: string): Promise<Int8Array | undefined>\n\n\t/**\n\t * Returns the privateKey of the provided key from the storage\n\t * @param storageEntryKey Key of the value to retrieve\n\t * @return The privateKey associated to the provided storageEntryKey in pkcs8 format or null if no entry has such key.\n\t * @throws IllegalEntityException if there is a value stored at the provided entry key, but it is not a private key\n\t */\n\tgetPrivateKeyPkcs8(storageEntryKey: string): Promise<Int8Array | undefined>\n\n\t/**\n\t * Delete the key associated to the provided storage entry key\n\t * @param storageEntryKey Key of the value to delete\n\t */\n\tdeleteKey(storageEntryKey: string): Promise<void>\n\n\t/**\n\t * Stores the given public key under the given key in the storage. If an entry already exists for the given storage\n\t * key, it will be overwritten; if you want to store the keypair just store the private key instead (with\n\t * [storePrivateKey]), since the public key is derivable from the private key.\n\t * @param storageEntryKey The id of the entry in storage\n\t * @param publicKeySpki the public key to store, in spki format\n\t */\n\tstorePublicKey(storageEntryKey: string, publicKeySpki: Int8Array): Promise<void>\n\n\t/**\n\t * Stores the given public key under the given key in the storage. If an entry already exists for the given storage\n\t * key, it will be overwritten.\n\t * @param storageEntryKey The id of the entry in storage\n\t * @param privateKey the private key to store, in pkcs8 format\n\t */\n\tstorePrivateKey(storageEntryKey: string, privateKey: Int8Array): Promise<void>\n}\n\nexport namespace KeyStorageFacade {\n\t/**\n\t * Factory method returning storage options that will cause the sdk to store the keys as string entries on the\n\t * provided storage facade. The raw keys data (spki or pkcs8) will be encoded as base 64\n\t */\n\texport function encodingAsBase64(baseStorage: StorageFacade | CardinalStorageOptions): CardinalKeyStorageOptions {\n\t\treturn InternalCardinalKeyStorageOptionsFactory.getInstance().encodingAsBase64(baseStorage)\n\t}\n\n\t/**\n\t * Factory method returning storage options that will cause the sdk to store the keys as string entries on the\n\t * provided storage facade. The keys will be stored as json in jwk format.\n\t */\n\texport function encodingAsJwk(baseStorage: StorageFacade | CardinalStorageOptions): CardinalKeyStorageOptions {\n\t\treturn InternalCardinalKeyStorageOptionsFactory.getInstance().encodingAsJwk(baseStorage)\n\t}\n}"]}